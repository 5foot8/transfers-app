
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model IncomingFlight
 * 
 */
export type IncomingFlight = $Result.DefaultSelection<Prisma.$IncomingFlightPayload>
/**
 * Model OutgoingFlight
 * 
 */
export type OutgoingFlight = $Result.DefaultSelection<Prisma.$OutgoingFlightPayload>
/**
 * Model OutgoingLink
 * 
 */
export type OutgoingLink = $Result.DefaultSelection<Prisma.$OutgoingLinkPayload>
/**
 * Model BagAssignment
 * 
 */
export type BagAssignment = $Result.DefaultSelection<Prisma.$BagAssignmentPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  ADMIN: 'ADMIN',
  MANAGER: 'MANAGER',
  OPERATOR: 'OPERATOR',
  VIEWER: 'VIEWER'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more IncomingFlights
 * const incomingFlights = await prisma.incomingFlight.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more IncomingFlights
   * const incomingFlights = await prisma.incomingFlight.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.incomingFlight`: Exposes CRUD operations for the **IncomingFlight** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IncomingFlights
    * const incomingFlights = await prisma.incomingFlight.findMany()
    * ```
    */
  get incomingFlight(): Prisma.IncomingFlightDelegate<ExtArgs>;

  /**
   * `prisma.outgoingFlight`: Exposes CRUD operations for the **OutgoingFlight** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OutgoingFlights
    * const outgoingFlights = await prisma.outgoingFlight.findMany()
    * ```
    */
  get outgoingFlight(): Prisma.OutgoingFlightDelegate<ExtArgs>;

  /**
   * `prisma.outgoingLink`: Exposes CRUD operations for the **OutgoingLink** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OutgoingLinks
    * const outgoingLinks = await prisma.outgoingLink.findMany()
    * ```
    */
  get outgoingLink(): Prisma.OutgoingLinkDelegate<ExtArgs>;

  /**
   * `prisma.bagAssignment`: Exposes CRUD operations for the **BagAssignment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BagAssignments
    * const bagAssignments = await prisma.bagAssignment.findMany()
    * ```
    */
  get bagAssignment(): Prisma.BagAssignmentDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    IncomingFlight: 'IncomingFlight',
    OutgoingFlight: 'OutgoingFlight',
    OutgoingLink: 'OutgoingLink',
    BagAssignment: 'BagAssignment',
    User: 'User'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "incomingFlight" | "outgoingFlight" | "outgoingLink" | "bagAssignment" | "user"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      IncomingFlight: {
        payload: Prisma.$IncomingFlightPayload<ExtArgs>
        fields: Prisma.IncomingFlightFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IncomingFlightFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncomingFlightPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IncomingFlightFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncomingFlightPayload>
          }
          findFirst: {
            args: Prisma.IncomingFlightFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncomingFlightPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IncomingFlightFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncomingFlightPayload>
          }
          findMany: {
            args: Prisma.IncomingFlightFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncomingFlightPayload>[]
          }
          create: {
            args: Prisma.IncomingFlightCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncomingFlightPayload>
          }
          createMany: {
            args: Prisma.IncomingFlightCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IncomingFlightCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncomingFlightPayload>[]
          }
          delete: {
            args: Prisma.IncomingFlightDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncomingFlightPayload>
          }
          update: {
            args: Prisma.IncomingFlightUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncomingFlightPayload>
          }
          deleteMany: {
            args: Prisma.IncomingFlightDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IncomingFlightUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.IncomingFlightUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncomingFlightPayload>
          }
          aggregate: {
            args: Prisma.IncomingFlightAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIncomingFlight>
          }
          groupBy: {
            args: Prisma.IncomingFlightGroupByArgs<ExtArgs>
            result: $Utils.Optional<IncomingFlightGroupByOutputType>[]
          }
          count: {
            args: Prisma.IncomingFlightCountArgs<ExtArgs>
            result: $Utils.Optional<IncomingFlightCountAggregateOutputType> | number
          }
        }
      }
      OutgoingFlight: {
        payload: Prisma.$OutgoingFlightPayload<ExtArgs>
        fields: Prisma.OutgoingFlightFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OutgoingFlightFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutgoingFlightPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OutgoingFlightFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutgoingFlightPayload>
          }
          findFirst: {
            args: Prisma.OutgoingFlightFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutgoingFlightPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OutgoingFlightFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutgoingFlightPayload>
          }
          findMany: {
            args: Prisma.OutgoingFlightFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutgoingFlightPayload>[]
          }
          create: {
            args: Prisma.OutgoingFlightCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutgoingFlightPayload>
          }
          createMany: {
            args: Prisma.OutgoingFlightCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OutgoingFlightCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutgoingFlightPayload>[]
          }
          delete: {
            args: Prisma.OutgoingFlightDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutgoingFlightPayload>
          }
          update: {
            args: Prisma.OutgoingFlightUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutgoingFlightPayload>
          }
          deleteMany: {
            args: Prisma.OutgoingFlightDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OutgoingFlightUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OutgoingFlightUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutgoingFlightPayload>
          }
          aggregate: {
            args: Prisma.OutgoingFlightAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOutgoingFlight>
          }
          groupBy: {
            args: Prisma.OutgoingFlightGroupByArgs<ExtArgs>
            result: $Utils.Optional<OutgoingFlightGroupByOutputType>[]
          }
          count: {
            args: Prisma.OutgoingFlightCountArgs<ExtArgs>
            result: $Utils.Optional<OutgoingFlightCountAggregateOutputType> | number
          }
        }
      }
      OutgoingLink: {
        payload: Prisma.$OutgoingLinkPayload<ExtArgs>
        fields: Prisma.OutgoingLinkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OutgoingLinkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutgoingLinkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OutgoingLinkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutgoingLinkPayload>
          }
          findFirst: {
            args: Prisma.OutgoingLinkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutgoingLinkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OutgoingLinkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutgoingLinkPayload>
          }
          findMany: {
            args: Prisma.OutgoingLinkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutgoingLinkPayload>[]
          }
          create: {
            args: Prisma.OutgoingLinkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutgoingLinkPayload>
          }
          createMany: {
            args: Prisma.OutgoingLinkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OutgoingLinkCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutgoingLinkPayload>[]
          }
          delete: {
            args: Prisma.OutgoingLinkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutgoingLinkPayload>
          }
          update: {
            args: Prisma.OutgoingLinkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutgoingLinkPayload>
          }
          deleteMany: {
            args: Prisma.OutgoingLinkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OutgoingLinkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OutgoingLinkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutgoingLinkPayload>
          }
          aggregate: {
            args: Prisma.OutgoingLinkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOutgoingLink>
          }
          groupBy: {
            args: Prisma.OutgoingLinkGroupByArgs<ExtArgs>
            result: $Utils.Optional<OutgoingLinkGroupByOutputType>[]
          }
          count: {
            args: Prisma.OutgoingLinkCountArgs<ExtArgs>
            result: $Utils.Optional<OutgoingLinkCountAggregateOutputType> | number
          }
        }
      }
      BagAssignment: {
        payload: Prisma.$BagAssignmentPayload<ExtArgs>
        fields: Prisma.BagAssignmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BagAssignmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BagAssignmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BagAssignmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BagAssignmentPayload>
          }
          findFirst: {
            args: Prisma.BagAssignmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BagAssignmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BagAssignmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BagAssignmentPayload>
          }
          findMany: {
            args: Prisma.BagAssignmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BagAssignmentPayload>[]
          }
          create: {
            args: Prisma.BagAssignmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BagAssignmentPayload>
          }
          createMany: {
            args: Prisma.BagAssignmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BagAssignmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BagAssignmentPayload>[]
          }
          delete: {
            args: Prisma.BagAssignmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BagAssignmentPayload>
          }
          update: {
            args: Prisma.BagAssignmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BagAssignmentPayload>
          }
          deleteMany: {
            args: Prisma.BagAssignmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BagAssignmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BagAssignmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BagAssignmentPayload>
          }
          aggregate: {
            args: Prisma.BagAssignmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBagAssignment>
          }
          groupBy: {
            args: Prisma.BagAssignmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<BagAssignmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.BagAssignmentCountArgs<ExtArgs>
            result: $Utils.Optional<BagAssignmentCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type IncomingFlightCountOutputType
   */

  export type IncomingFlightCountOutputType = {
    outgoingLinks: number
  }

  export type IncomingFlightCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    outgoingLinks?: boolean | IncomingFlightCountOutputTypeCountOutgoingLinksArgs
  }

  // Custom InputTypes
  /**
   * IncomingFlightCountOutputType without action
   */
  export type IncomingFlightCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncomingFlightCountOutputType
     */
    select?: IncomingFlightCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * IncomingFlightCountOutputType without action
   */
  export type IncomingFlightCountOutputTypeCountOutgoingLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OutgoingLinkWhereInput
  }


  /**
   * Count Type OutgoingFlightCountOutputType
   */

  export type OutgoingFlightCountOutputType = {
    incomingLinks: number
    bagsFromIncoming: number
  }

  export type OutgoingFlightCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    incomingLinks?: boolean | OutgoingFlightCountOutputTypeCountIncomingLinksArgs
    bagsFromIncoming?: boolean | OutgoingFlightCountOutputTypeCountBagsFromIncomingArgs
  }

  // Custom InputTypes
  /**
   * OutgoingFlightCountOutputType without action
   */
  export type OutgoingFlightCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutgoingFlightCountOutputType
     */
    select?: OutgoingFlightCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OutgoingFlightCountOutputType without action
   */
  export type OutgoingFlightCountOutputTypeCountIncomingLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OutgoingLinkWhereInput
  }

  /**
   * OutgoingFlightCountOutputType without action
   */
  export type OutgoingFlightCountOutputTypeCountBagsFromIncomingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BagAssignmentWhereInput
  }


  /**
   * Models
   */

  /**
   * Model IncomingFlight
   */

  export type AggregateIncomingFlight = {
    _count: IncomingFlightCountAggregateOutputType | null
    _avg: IncomingFlightAvgAggregateOutputType | null
    _sum: IncomingFlightSumAggregateOutputType | null
    _min: IncomingFlightMinAggregateOutputType | null
    _max: IncomingFlightMaxAggregateOutputType | null
  }

  export type IncomingFlightAvgAggregateOutputType = {
    screeningBags: number | null
  }

  export type IncomingFlightSumAggregateOutputType = {
    screeningBags: number | null
  }

  export type IncomingFlightMinAggregateOutputType = {
    id: string | null
    flightNumber: string | null
    terminal: string | null
    origin: string | null
    scheduledTime: Date | null
    actualArrivalTime: Date | null
    expectedArrivalTime: Date | null
    cancelled: boolean | null
    collectedTime: Date | null
    deliveredTime: Date | null
    screeningStartTime: Date | null
    screeningEndTime: Date | null
    screeningBags: number | null
    bagAvailableTime: Date | null
    carousel: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IncomingFlightMaxAggregateOutputType = {
    id: string | null
    flightNumber: string | null
    terminal: string | null
    origin: string | null
    scheduledTime: Date | null
    actualArrivalTime: Date | null
    expectedArrivalTime: Date | null
    cancelled: boolean | null
    collectedTime: Date | null
    deliveredTime: Date | null
    screeningStartTime: Date | null
    screeningEndTime: Date | null
    screeningBags: number | null
    bagAvailableTime: Date | null
    carousel: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IncomingFlightCountAggregateOutputType = {
    id: number
    flightNumber: number
    terminal: number
    origin: number
    scheduledTime: number
    actualArrivalTime: number
    expectedArrivalTime: number
    cancelled: number
    collectedTime: number
    deliveredTime: number
    screeningStartTime: number
    screeningEndTime: number
    screeningBags: number
    bagAvailableTime: number
    carousel: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type IncomingFlightAvgAggregateInputType = {
    screeningBags?: true
  }

  export type IncomingFlightSumAggregateInputType = {
    screeningBags?: true
  }

  export type IncomingFlightMinAggregateInputType = {
    id?: true
    flightNumber?: true
    terminal?: true
    origin?: true
    scheduledTime?: true
    actualArrivalTime?: true
    expectedArrivalTime?: true
    cancelled?: true
    collectedTime?: true
    deliveredTime?: true
    screeningStartTime?: true
    screeningEndTime?: true
    screeningBags?: true
    bagAvailableTime?: true
    carousel?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IncomingFlightMaxAggregateInputType = {
    id?: true
    flightNumber?: true
    terminal?: true
    origin?: true
    scheduledTime?: true
    actualArrivalTime?: true
    expectedArrivalTime?: true
    cancelled?: true
    collectedTime?: true
    deliveredTime?: true
    screeningStartTime?: true
    screeningEndTime?: true
    screeningBags?: true
    bagAvailableTime?: true
    carousel?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IncomingFlightCountAggregateInputType = {
    id?: true
    flightNumber?: true
    terminal?: true
    origin?: true
    scheduledTime?: true
    actualArrivalTime?: true
    expectedArrivalTime?: true
    cancelled?: true
    collectedTime?: true
    deliveredTime?: true
    screeningStartTime?: true
    screeningEndTime?: true
    screeningBags?: true
    bagAvailableTime?: true
    carousel?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type IncomingFlightAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IncomingFlight to aggregate.
     */
    where?: IncomingFlightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IncomingFlights to fetch.
     */
    orderBy?: IncomingFlightOrderByWithRelationInput | IncomingFlightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IncomingFlightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IncomingFlights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IncomingFlights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IncomingFlights
    **/
    _count?: true | IncomingFlightCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IncomingFlightAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IncomingFlightSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IncomingFlightMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IncomingFlightMaxAggregateInputType
  }

  export type GetIncomingFlightAggregateType<T extends IncomingFlightAggregateArgs> = {
        [P in keyof T & keyof AggregateIncomingFlight]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIncomingFlight[P]>
      : GetScalarType<T[P], AggregateIncomingFlight[P]>
  }




  export type IncomingFlightGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IncomingFlightWhereInput
    orderBy?: IncomingFlightOrderByWithAggregationInput | IncomingFlightOrderByWithAggregationInput[]
    by: IncomingFlightScalarFieldEnum[] | IncomingFlightScalarFieldEnum
    having?: IncomingFlightScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IncomingFlightCountAggregateInputType | true
    _avg?: IncomingFlightAvgAggregateInputType
    _sum?: IncomingFlightSumAggregateInputType
    _min?: IncomingFlightMinAggregateInputType
    _max?: IncomingFlightMaxAggregateInputType
  }

  export type IncomingFlightGroupByOutputType = {
    id: string
    flightNumber: string
    terminal: string
    origin: string
    scheduledTime: Date
    actualArrivalTime: Date | null
    expectedArrivalTime: Date | null
    cancelled: boolean
    collectedTime: Date | null
    deliveredTime: Date | null
    screeningStartTime: Date | null
    screeningEndTime: Date | null
    screeningBags: number | null
    bagAvailableTime: Date | null
    carousel: string | null
    notes: string
    createdAt: Date
    updatedAt: Date
    _count: IncomingFlightCountAggregateOutputType | null
    _avg: IncomingFlightAvgAggregateOutputType | null
    _sum: IncomingFlightSumAggregateOutputType | null
    _min: IncomingFlightMinAggregateOutputType | null
    _max: IncomingFlightMaxAggregateOutputType | null
  }

  type GetIncomingFlightGroupByPayload<T extends IncomingFlightGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IncomingFlightGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IncomingFlightGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IncomingFlightGroupByOutputType[P]>
            : GetScalarType<T[P], IncomingFlightGroupByOutputType[P]>
        }
      >
    >


  export type IncomingFlightSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    flightNumber?: boolean
    terminal?: boolean
    origin?: boolean
    scheduledTime?: boolean
    actualArrivalTime?: boolean
    expectedArrivalTime?: boolean
    cancelled?: boolean
    collectedTime?: boolean
    deliveredTime?: boolean
    screeningStartTime?: boolean
    screeningEndTime?: boolean
    screeningBags?: boolean
    bagAvailableTime?: boolean
    carousel?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    outgoingLinks?: boolean | IncomingFlight$outgoingLinksArgs<ExtArgs>
    _count?: boolean | IncomingFlightCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["incomingFlight"]>

  export type IncomingFlightSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    flightNumber?: boolean
    terminal?: boolean
    origin?: boolean
    scheduledTime?: boolean
    actualArrivalTime?: boolean
    expectedArrivalTime?: boolean
    cancelled?: boolean
    collectedTime?: boolean
    deliveredTime?: boolean
    screeningStartTime?: boolean
    screeningEndTime?: boolean
    screeningBags?: boolean
    bagAvailableTime?: boolean
    carousel?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["incomingFlight"]>

  export type IncomingFlightSelectScalar = {
    id?: boolean
    flightNumber?: boolean
    terminal?: boolean
    origin?: boolean
    scheduledTime?: boolean
    actualArrivalTime?: boolean
    expectedArrivalTime?: boolean
    cancelled?: boolean
    collectedTime?: boolean
    deliveredTime?: boolean
    screeningStartTime?: boolean
    screeningEndTime?: boolean
    screeningBags?: boolean
    bagAvailableTime?: boolean
    carousel?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type IncomingFlightInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    outgoingLinks?: boolean | IncomingFlight$outgoingLinksArgs<ExtArgs>
    _count?: boolean | IncomingFlightCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type IncomingFlightIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $IncomingFlightPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IncomingFlight"
    objects: {
      outgoingLinks: Prisma.$OutgoingLinkPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      flightNumber: string
      terminal: string
      origin: string
      scheduledTime: Date
      actualArrivalTime: Date | null
      expectedArrivalTime: Date | null
      cancelled: boolean
      collectedTime: Date | null
      deliveredTime: Date | null
      screeningStartTime: Date | null
      screeningEndTime: Date | null
      screeningBags: number | null
      bagAvailableTime: Date | null
      carousel: string | null
      notes: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["incomingFlight"]>
    composites: {}
  }

  type IncomingFlightGetPayload<S extends boolean | null | undefined | IncomingFlightDefaultArgs> = $Result.GetResult<Prisma.$IncomingFlightPayload, S>

  type IncomingFlightCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<IncomingFlightFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: IncomingFlightCountAggregateInputType | true
    }

  export interface IncomingFlightDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IncomingFlight'], meta: { name: 'IncomingFlight' } }
    /**
     * Find zero or one IncomingFlight that matches the filter.
     * @param {IncomingFlightFindUniqueArgs} args - Arguments to find a IncomingFlight
     * @example
     * // Get one IncomingFlight
     * const incomingFlight = await prisma.incomingFlight.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IncomingFlightFindUniqueArgs>(args: SelectSubset<T, IncomingFlightFindUniqueArgs<ExtArgs>>): Prisma__IncomingFlightClient<$Result.GetResult<Prisma.$IncomingFlightPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one IncomingFlight that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {IncomingFlightFindUniqueOrThrowArgs} args - Arguments to find a IncomingFlight
     * @example
     * // Get one IncomingFlight
     * const incomingFlight = await prisma.incomingFlight.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IncomingFlightFindUniqueOrThrowArgs>(args: SelectSubset<T, IncomingFlightFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IncomingFlightClient<$Result.GetResult<Prisma.$IncomingFlightPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first IncomingFlight that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomingFlightFindFirstArgs} args - Arguments to find a IncomingFlight
     * @example
     * // Get one IncomingFlight
     * const incomingFlight = await prisma.incomingFlight.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IncomingFlightFindFirstArgs>(args?: SelectSubset<T, IncomingFlightFindFirstArgs<ExtArgs>>): Prisma__IncomingFlightClient<$Result.GetResult<Prisma.$IncomingFlightPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first IncomingFlight that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomingFlightFindFirstOrThrowArgs} args - Arguments to find a IncomingFlight
     * @example
     * // Get one IncomingFlight
     * const incomingFlight = await prisma.incomingFlight.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IncomingFlightFindFirstOrThrowArgs>(args?: SelectSubset<T, IncomingFlightFindFirstOrThrowArgs<ExtArgs>>): Prisma__IncomingFlightClient<$Result.GetResult<Prisma.$IncomingFlightPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more IncomingFlights that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomingFlightFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IncomingFlights
     * const incomingFlights = await prisma.incomingFlight.findMany()
     * 
     * // Get first 10 IncomingFlights
     * const incomingFlights = await prisma.incomingFlight.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const incomingFlightWithIdOnly = await prisma.incomingFlight.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IncomingFlightFindManyArgs>(args?: SelectSubset<T, IncomingFlightFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncomingFlightPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a IncomingFlight.
     * @param {IncomingFlightCreateArgs} args - Arguments to create a IncomingFlight.
     * @example
     * // Create one IncomingFlight
     * const IncomingFlight = await prisma.incomingFlight.create({
     *   data: {
     *     // ... data to create a IncomingFlight
     *   }
     * })
     * 
     */
    create<T extends IncomingFlightCreateArgs>(args: SelectSubset<T, IncomingFlightCreateArgs<ExtArgs>>): Prisma__IncomingFlightClient<$Result.GetResult<Prisma.$IncomingFlightPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many IncomingFlights.
     * @param {IncomingFlightCreateManyArgs} args - Arguments to create many IncomingFlights.
     * @example
     * // Create many IncomingFlights
     * const incomingFlight = await prisma.incomingFlight.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IncomingFlightCreateManyArgs>(args?: SelectSubset<T, IncomingFlightCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many IncomingFlights and returns the data saved in the database.
     * @param {IncomingFlightCreateManyAndReturnArgs} args - Arguments to create many IncomingFlights.
     * @example
     * // Create many IncomingFlights
     * const incomingFlight = await prisma.incomingFlight.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many IncomingFlights and only return the `id`
     * const incomingFlightWithIdOnly = await prisma.incomingFlight.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IncomingFlightCreateManyAndReturnArgs>(args?: SelectSubset<T, IncomingFlightCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncomingFlightPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a IncomingFlight.
     * @param {IncomingFlightDeleteArgs} args - Arguments to delete one IncomingFlight.
     * @example
     * // Delete one IncomingFlight
     * const IncomingFlight = await prisma.incomingFlight.delete({
     *   where: {
     *     // ... filter to delete one IncomingFlight
     *   }
     * })
     * 
     */
    delete<T extends IncomingFlightDeleteArgs>(args: SelectSubset<T, IncomingFlightDeleteArgs<ExtArgs>>): Prisma__IncomingFlightClient<$Result.GetResult<Prisma.$IncomingFlightPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one IncomingFlight.
     * @param {IncomingFlightUpdateArgs} args - Arguments to update one IncomingFlight.
     * @example
     * // Update one IncomingFlight
     * const incomingFlight = await prisma.incomingFlight.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IncomingFlightUpdateArgs>(args: SelectSubset<T, IncomingFlightUpdateArgs<ExtArgs>>): Prisma__IncomingFlightClient<$Result.GetResult<Prisma.$IncomingFlightPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more IncomingFlights.
     * @param {IncomingFlightDeleteManyArgs} args - Arguments to filter IncomingFlights to delete.
     * @example
     * // Delete a few IncomingFlights
     * const { count } = await prisma.incomingFlight.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IncomingFlightDeleteManyArgs>(args?: SelectSubset<T, IncomingFlightDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IncomingFlights.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomingFlightUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IncomingFlights
     * const incomingFlight = await prisma.incomingFlight.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IncomingFlightUpdateManyArgs>(args: SelectSubset<T, IncomingFlightUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one IncomingFlight.
     * @param {IncomingFlightUpsertArgs} args - Arguments to update or create a IncomingFlight.
     * @example
     * // Update or create a IncomingFlight
     * const incomingFlight = await prisma.incomingFlight.upsert({
     *   create: {
     *     // ... data to create a IncomingFlight
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IncomingFlight we want to update
     *   }
     * })
     */
    upsert<T extends IncomingFlightUpsertArgs>(args: SelectSubset<T, IncomingFlightUpsertArgs<ExtArgs>>): Prisma__IncomingFlightClient<$Result.GetResult<Prisma.$IncomingFlightPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of IncomingFlights.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomingFlightCountArgs} args - Arguments to filter IncomingFlights to count.
     * @example
     * // Count the number of IncomingFlights
     * const count = await prisma.incomingFlight.count({
     *   where: {
     *     // ... the filter for the IncomingFlights we want to count
     *   }
     * })
    **/
    count<T extends IncomingFlightCountArgs>(
      args?: Subset<T, IncomingFlightCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IncomingFlightCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IncomingFlight.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomingFlightAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IncomingFlightAggregateArgs>(args: Subset<T, IncomingFlightAggregateArgs>): Prisma.PrismaPromise<GetIncomingFlightAggregateType<T>>

    /**
     * Group by IncomingFlight.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomingFlightGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IncomingFlightGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IncomingFlightGroupByArgs['orderBy'] }
        : { orderBy?: IncomingFlightGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IncomingFlightGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIncomingFlightGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IncomingFlight model
   */
  readonly fields: IncomingFlightFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IncomingFlight.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IncomingFlightClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    outgoingLinks<T extends IncomingFlight$outgoingLinksArgs<ExtArgs> = {}>(args?: Subset<T, IncomingFlight$outgoingLinksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OutgoingLinkPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the IncomingFlight model
   */ 
  interface IncomingFlightFieldRefs {
    readonly id: FieldRef<"IncomingFlight", 'String'>
    readonly flightNumber: FieldRef<"IncomingFlight", 'String'>
    readonly terminal: FieldRef<"IncomingFlight", 'String'>
    readonly origin: FieldRef<"IncomingFlight", 'String'>
    readonly scheduledTime: FieldRef<"IncomingFlight", 'DateTime'>
    readonly actualArrivalTime: FieldRef<"IncomingFlight", 'DateTime'>
    readonly expectedArrivalTime: FieldRef<"IncomingFlight", 'DateTime'>
    readonly cancelled: FieldRef<"IncomingFlight", 'Boolean'>
    readonly collectedTime: FieldRef<"IncomingFlight", 'DateTime'>
    readonly deliveredTime: FieldRef<"IncomingFlight", 'DateTime'>
    readonly screeningStartTime: FieldRef<"IncomingFlight", 'DateTime'>
    readonly screeningEndTime: FieldRef<"IncomingFlight", 'DateTime'>
    readonly screeningBags: FieldRef<"IncomingFlight", 'Int'>
    readonly bagAvailableTime: FieldRef<"IncomingFlight", 'DateTime'>
    readonly carousel: FieldRef<"IncomingFlight", 'String'>
    readonly notes: FieldRef<"IncomingFlight", 'String'>
    readonly createdAt: FieldRef<"IncomingFlight", 'DateTime'>
    readonly updatedAt: FieldRef<"IncomingFlight", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * IncomingFlight findUnique
   */
  export type IncomingFlightFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncomingFlight
     */
    select?: IncomingFlightSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncomingFlightInclude<ExtArgs> | null
    /**
     * Filter, which IncomingFlight to fetch.
     */
    where: IncomingFlightWhereUniqueInput
  }

  /**
   * IncomingFlight findUniqueOrThrow
   */
  export type IncomingFlightFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncomingFlight
     */
    select?: IncomingFlightSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncomingFlightInclude<ExtArgs> | null
    /**
     * Filter, which IncomingFlight to fetch.
     */
    where: IncomingFlightWhereUniqueInput
  }

  /**
   * IncomingFlight findFirst
   */
  export type IncomingFlightFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncomingFlight
     */
    select?: IncomingFlightSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncomingFlightInclude<ExtArgs> | null
    /**
     * Filter, which IncomingFlight to fetch.
     */
    where?: IncomingFlightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IncomingFlights to fetch.
     */
    orderBy?: IncomingFlightOrderByWithRelationInput | IncomingFlightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IncomingFlights.
     */
    cursor?: IncomingFlightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IncomingFlights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IncomingFlights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IncomingFlights.
     */
    distinct?: IncomingFlightScalarFieldEnum | IncomingFlightScalarFieldEnum[]
  }

  /**
   * IncomingFlight findFirstOrThrow
   */
  export type IncomingFlightFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncomingFlight
     */
    select?: IncomingFlightSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncomingFlightInclude<ExtArgs> | null
    /**
     * Filter, which IncomingFlight to fetch.
     */
    where?: IncomingFlightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IncomingFlights to fetch.
     */
    orderBy?: IncomingFlightOrderByWithRelationInput | IncomingFlightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IncomingFlights.
     */
    cursor?: IncomingFlightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IncomingFlights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IncomingFlights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IncomingFlights.
     */
    distinct?: IncomingFlightScalarFieldEnum | IncomingFlightScalarFieldEnum[]
  }

  /**
   * IncomingFlight findMany
   */
  export type IncomingFlightFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncomingFlight
     */
    select?: IncomingFlightSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncomingFlightInclude<ExtArgs> | null
    /**
     * Filter, which IncomingFlights to fetch.
     */
    where?: IncomingFlightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IncomingFlights to fetch.
     */
    orderBy?: IncomingFlightOrderByWithRelationInput | IncomingFlightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IncomingFlights.
     */
    cursor?: IncomingFlightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IncomingFlights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IncomingFlights.
     */
    skip?: number
    distinct?: IncomingFlightScalarFieldEnum | IncomingFlightScalarFieldEnum[]
  }

  /**
   * IncomingFlight create
   */
  export type IncomingFlightCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncomingFlight
     */
    select?: IncomingFlightSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncomingFlightInclude<ExtArgs> | null
    /**
     * The data needed to create a IncomingFlight.
     */
    data: XOR<IncomingFlightCreateInput, IncomingFlightUncheckedCreateInput>
  }

  /**
   * IncomingFlight createMany
   */
  export type IncomingFlightCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IncomingFlights.
     */
    data: IncomingFlightCreateManyInput | IncomingFlightCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * IncomingFlight createManyAndReturn
   */
  export type IncomingFlightCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncomingFlight
     */
    select?: IncomingFlightSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many IncomingFlights.
     */
    data: IncomingFlightCreateManyInput | IncomingFlightCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * IncomingFlight update
   */
  export type IncomingFlightUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncomingFlight
     */
    select?: IncomingFlightSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncomingFlightInclude<ExtArgs> | null
    /**
     * The data needed to update a IncomingFlight.
     */
    data: XOR<IncomingFlightUpdateInput, IncomingFlightUncheckedUpdateInput>
    /**
     * Choose, which IncomingFlight to update.
     */
    where: IncomingFlightWhereUniqueInput
  }

  /**
   * IncomingFlight updateMany
   */
  export type IncomingFlightUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IncomingFlights.
     */
    data: XOR<IncomingFlightUpdateManyMutationInput, IncomingFlightUncheckedUpdateManyInput>
    /**
     * Filter which IncomingFlights to update
     */
    where?: IncomingFlightWhereInput
  }

  /**
   * IncomingFlight upsert
   */
  export type IncomingFlightUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncomingFlight
     */
    select?: IncomingFlightSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncomingFlightInclude<ExtArgs> | null
    /**
     * The filter to search for the IncomingFlight to update in case it exists.
     */
    where: IncomingFlightWhereUniqueInput
    /**
     * In case the IncomingFlight found by the `where` argument doesn't exist, create a new IncomingFlight with this data.
     */
    create: XOR<IncomingFlightCreateInput, IncomingFlightUncheckedCreateInput>
    /**
     * In case the IncomingFlight was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IncomingFlightUpdateInput, IncomingFlightUncheckedUpdateInput>
  }

  /**
   * IncomingFlight delete
   */
  export type IncomingFlightDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncomingFlight
     */
    select?: IncomingFlightSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncomingFlightInclude<ExtArgs> | null
    /**
     * Filter which IncomingFlight to delete.
     */
    where: IncomingFlightWhereUniqueInput
  }

  /**
   * IncomingFlight deleteMany
   */
  export type IncomingFlightDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IncomingFlights to delete
     */
    where?: IncomingFlightWhereInput
  }

  /**
   * IncomingFlight.outgoingLinks
   */
  export type IncomingFlight$outgoingLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutgoingLink
     */
    select?: OutgoingLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutgoingLinkInclude<ExtArgs> | null
    where?: OutgoingLinkWhereInput
    orderBy?: OutgoingLinkOrderByWithRelationInput | OutgoingLinkOrderByWithRelationInput[]
    cursor?: OutgoingLinkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OutgoingLinkScalarFieldEnum | OutgoingLinkScalarFieldEnum[]
  }

  /**
   * IncomingFlight without action
   */
  export type IncomingFlightDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IncomingFlight
     */
    select?: IncomingFlightSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IncomingFlightInclude<ExtArgs> | null
  }


  /**
   * Model OutgoingFlight
   */

  export type AggregateOutgoingFlight = {
    _count: OutgoingFlightCountAggregateOutputType | null
    _min: OutgoingFlightMinAggregateOutputType | null
    _max: OutgoingFlightMaxAggregateOutputType | null
  }

  export type OutgoingFlightMinAggregateOutputType = {
    id: string | null
    flightNumber: string | null
    terminal: string | null
    destination: string | null
    scheduledTime: Date | null
    actualTime: Date | null
    expectedTime: Date | null
    cancelled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OutgoingFlightMaxAggregateOutputType = {
    id: string | null
    flightNumber: string | null
    terminal: string | null
    destination: string | null
    scheduledTime: Date | null
    actualTime: Date | null
    expectedTime: Date | null
    cancelled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OutgoingFlightCountAggregateOutputType = {
    id: number
    flightNumber: number
    terminal: number
    destination: number
    scheduledTime: number
    actualTime: number
    expectedTime: number
    cancelled: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OutgoingFlightMinAggregateInputType = {
    id?: true
    flightNumber?: true
    terminal?: true
    destination?: true
    scheduledTime?: true
    actualTime?: true
    expectedTime?: true
    cancelled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OutgoingFlightMaxAggregateInputType = {
    id?: true
    flightNumber?: true
    terminal?: true
    destination?: true
    scheduledTime?: true
    actualTime?: true
    expectedTime?: true
    cancelled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OutgoingFlightCountAggregateInputType = {
    id?: true
    flightNumber?: true
    terminal?: true
    destination?: true
    scheduledTime?: true
    actualTime?: true
    expectedTime?: true
    cancelled?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OutgoingFlightAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OutgoingFlight to aggregate.
     */
    where?: OutgoingFlightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OutgoingFlights to fetch.
     */
    orderBy?: OutgoingFlightOrderByWithRelationInput | OutgoingFlightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OutgoingFlightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OutgoingFlights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OutgoingFlights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OutgoingFlights
    **/
    _count?: true | OutgoingFlightCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OutgoingFlightMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OutgoingFlightMaxAggregateInputType
  }

  export type GetOutgoingFlightAggregateType<T extends OutgoingFlightAggregateArgs> = {
        [P in keyof T & keyof AggregateOutgoingFlight]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOutgoingFlight[P]>
      : GetScalarType<T[P], AggregateOutgoingFlight[P]>
  }




  export type OutgoingFlightGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OutgoingFlightWhereInput
    orderBy?: OutgoingFlightOrderByWithAggregationInput | OutgoingFlightOrderByWithAggregationInput[]
    by: OutgoingFlightScalarFieldEnum[] | OutgoingFlightScalarFieldEnum
    having?: OutgoingFlightScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OutgoingFlightCountAggregateInputType | true
    _min?: OutgoingFlightMinAggregateInputType
    _max?: OutgoingFlightMaxAggregateInputType
  }

  export type OutgoingFlightGroupByOutputType = {
    id: string
    flightNumber: string
    terminal: string
    destination: string
    scheduledTime: Date
    actualTime: Date | null
    expectedTime: Date | null
    cancelled: boolean
    createdAt: Date
    updatedAt: Date
    _count: OutgoingFlightCountAggregateOutputType | null
    _min: OutgoingFlightMinAggregateOutputType | null
    _max: OutgoingFlightMaxAggregateOutputType | null
  }

  type GetOutgoingFlightGroupByPayload<T extends OutgoingFlightGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OutgoingFlightGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OutgoingFlightGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OutgoingFlightGroupByOutputType[P]>
            : GetScalarType<T[P], OutgoingFlightGroupByOutputType[P]>
        }
      >
    >


  export type OutgoingFlightSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    flightNumber?: boolean
    terminal?: boolean
    destination?: boolean
    scheduledTime?: boolean
    actualTime?: boolean
    expectedTime?: boolean
    cancelled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    incomingLinks?: boolean | OutgoingFlight$incomingLinksArgs<ExtArgs>
    bagsFromIncoming?: boolean | OutgoingFlight$bagsFromIncomingArgs<ExtArgs>
    _count?: boolean | OutgoingFlightCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["outgoingFlight"]>

  export type OutgoingFlightSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    flightNumber?: boolean
    terminal?: boolean
    destination?: boolean
    scheduledTime?: boolean
    actualTime?: boolean
    expectedTime?: boolean
    cancelled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["outgoingFlight"]>

  export type OutgoingFlightSelectScalar = {
    id?: boolean
    flightNumber?: boolean
    terminal?: boolean
    destination?: boolean
    scheduledTime?: boolean
    actualTime?: boolean
    expectedTime?: boolean
    cancelled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OutgoingFlightInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    incomingLinks?: boolean | OutgoingFlight$incomingLinksArgs<ExtArgs>
    bagsFromIncoming?: boolean | OutgoingFlight$bagsFromIncomingArgs<ExtArgs>
    _count?: boolean | OutgoingFlightCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OutgoingFlightIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $OutgoingFlightPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OutgoingFlight"
    objects: {
      incomingLinks: Prisma.$OutgoingLinkPayload<ExtArgs>[]
      bagsFromIncoming: Prisma.$BagAssignmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      flightNumber: string
      terminal: string
      destination: string
      scheduledTime: Date
      actualTime: Date | null
      expectedTime: Date | null
      cancelled: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["outgoingFlight"]>
    composites: {}
  }

  type OutgoingFlightGetPayload<S extends boolean | null | undefined | OutgoingFlightDefaultArgs> = $Result.GetResult<Prisma.$OutgoingFlightPayload, S>

  type OutgoingFlightCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OutgoingFlightFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OutgoingFlightCountAggregateInputType | true
    }

  export interface OutgoingFlightDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OutgoingFlight'], meta: { name: 'OutgoingFlight' } }
    /**
     * Find zero or one OutgoingFlight that matches the filter.
     * @param {OutgoingFlightFindUniqueArgs} args - Arguments to find a OutgoingFlight
     * @example
     * // Get one OutgoingFlight
     * const outgoingFlight = await prisma.outgoingFlight.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OutgoingFlightFindUniqueArgs>(args: SelectSubset<T, OutgoingFlightFindUniqueArgs<ExtArgs>>): Prisma__OutgoingFlightClient<$Result.GetResult<Prisma.$OutgoingFlightPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one OutgoingFlight that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OutgoingFlightFindUniqueOrThrowArgs} args - Arguments to find a OutgoingFlight
     * @example
     * // Get one OutgoingFlight
     * const outgoingFlight = await prisma.outgoingFlight.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OutgoingFlightFindUniqueOrThrowArgs>(args: SelectSubset<T, OutgoingFlightFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OutgoingFlightClient<$Result.GetResult<Prisma.$OutgoingFlightPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first OutgoingFlight that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutgoingFlightFindFirstArgs} args - Arguments to find a OutgoingFlight
     * @example
     * // Get one OutgoingFlight
     * const outgoingFlight = await prisma.outgoingFlight.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OutgoingFlightFindFirstArgs>(args?: SelectSubset<T, OutgoingFlightFindFirstArgs<ExtArgs>>): Prisma__OutgoingFlightClient<$Result.GetResult<Prisma.$OutgoingFlightPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first OutgoingFlight that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutgoingFlightFindFirstOrThrowArgs} args - Arguments to find a OutgoingFlight
     * @example
     * // Get one OutgoingFlight
     * const outgoingFlight = await prisma.outgoingFlight.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OutgoingFlightFindFirstOrThrowArgs>(args?: SelectSubset<T, OutgoingFlightFindFirstOrThrowArgs<ExtArgs>>): Prisma__OutgoingFlightClient<$Result.GetResult<Prisma.$OutgoingFlightPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more OutgoingFlights that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutgoingFlightFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OutgoingFlights
     * const outgoingFlights = await prisma.outgoingFlight.findMany()
     * 
     * // Get first 10 OutgoingFlights
     * const outgoingFlights = await prisma.outgoingFlight.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const outgoingFlightWithIdOnly = await prisma.outgoingFlight.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OutgoingFlightFindManyArgs>(args?: SelectSubset<T, OutgoingFlightFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OutgoingFlightPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a OutgoingFlight.
     * @param {OutgoingFlightCreateArgs} args - Arguments to create a OutgoingFlight.
     * @example
     * // Create one OutgoingFlight
     * const OutgoingFlight = await prisma.outgoingFlight.create({
     *   data: {
     *     // ... data to create a OutgoingFlight
     *   }
     * })
     * 
     */
    create<T extends OutgoingFlightCreateArgs>(args: SelectSubset<T, OutgoingFlightCreateArgs<ExtArgs>>): Prisma__OutgoingFlightClient<$Result.GetResult<Prisma.$OutgoingFlightPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many OutgoingFlights.
     * @param {OutgoingFlightCreateManyArgs} args - Arguments to create many OutgoingFlights.
     * @example
     * // Create many OutgoingFlights
     * const outgoingFlight = await prisma.outgoingFlight.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OutgoingFlightCreateManyArgs>(args?: SelectSubset<T, OutgoingFlightCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OutgoingFlights and returns the data saved in the database.
     * @param {OutgoingFlightCreateManyAndReturnArgs} args - Arguments to create many OutgoingFlights.
     * @example
     * // Create many OutgoingFlights
     * const outgoingFlight = await prisma.outgoingFlight.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OutgoingFlights and only return the `id`
     * const outgoingFlightWithIdOnly = await prisma.outgoingFlight.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OutgoingFlightCreateManyAndReturnArgs>(args?: SelectSubset<T, OutgoingFlightCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OutgoingFlightPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a OutgoingFlight.
     * @param {OutgoingFlightDeleteArgs} args - Arguments to delete one OutgoingFlight.
     * @example
     * // Delete one OutgoingFlight
     * const OutgoingFlight = await prisma.outgoingFlight.delete({
     *   where: {
     *     // ... filter to delete one OutgoingFlight
     *   }
     * })
     * 
     */
    delete<T extends OutgoingFlightDeleteArgs>(args: SelectSubset<T, OutgoingFlightDeleteArgs<ExtArgs>>): Prisma__OutgoingFlightClient<$Result.GetResult<Prisma.$OutgoingFlightPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one OutgoingFlight.
     * @param {OutgoingFlightUpdateArgs} args - Arguments to update one OutgoingFlight.
     * @example
     * // Update one OutgoingFlight
     * const outgoingFlight = await prisma.outgoingFlight.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OutgoingFlightUpdateArgs>(args: SelectSubset<T, OutgoingFlightUpdateArgs<ExtArgs>>): Prisma__OutgoingFlightClient<$Result.GetResult<Prisma.$OutgoingFlightPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more OutgoingFlights.
     * @param {OutgoingFlightDeleteManyArgs} args - Arguments to filter OutgoingFlights to delete.
     * @example
     * // Delete a few OutgoingFlights
     * const { count } = await prisma.outgoingFlight.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OutgoingFlightDeleteManyArgs>(args?: SelectSubset<T, OutgoingFlightDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OutgoingFlights.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutgoingFlightUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OutgoingFlights
     * const outgoingFlight = await prisma.outgoingFlight.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OutgoingFlightUpdateManyArgs>(args: SelectSubset<T, OutgoingFlightUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OutgoingFlight.
     * @param {OutgoingFlightUpsertArgs} args - Arguments to update or create a OutgoingFlight.
     * @example
     * // Update or create a OutgoingFlight
     * const outgoingFlight = await prisma.outgoingFlight.upsert({
     *   create: {
     *     // ... data to create a OutgoingFlight
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OutgoingFlight we want to update
     *   }
     * })
     */
    upsert<T extends OutgoingFlightUpsertArgs>(args: SelectSubset<T, OutgoingFlightUpsertArgs<ExtArgs>>): Prisma__OutgoingFlightClient<$Result.GetResult<Prisma.$OutgoingFlightPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of OutgoingFlights.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutgoingFlightCountArgs} args - Arguments to filter OutgoingFlights to count.
     * @example
     * // Count the number of OutgoingFlights
     * const count = await prisma.outgoingFlight.count({
     *   where: {
     *     // ... the filter for the OutgoingFlights we want to count
     *   }
     * })
    **/
    count<T extends OutgoingFlightCountArgs>(
      args?: Subset<T, OutgoingFlightCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OutgoingFlightCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OutgoingFlight.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutgoingFlightAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OutgoingFlightAggregateArgs>(args: Subset<T, OutgoingFlightAggregateArgs>): Prisma.PrismaPromise<GetOutgoingFlightAggregateType<T>>

    /**
     * Group by OutgoingFlight.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutgoingFlightGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OutgoingFlightGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OutgoingFlightGroupByArgs['orderBy'] }
        : { orderBy?: OutgoingFlightGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OutgoingFlightGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOutgoingFlightGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OutgoingFlight model
   */
  readonly fields: OutgoingFlightFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OutgoingFlight.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OutgoingFlightClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    incomingLinks<T extends OutgoingFlight$incomingLinksArgs<ExtArgs> = {}>(args?: Subset<T, OutgoingFlight$incomingLinksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OutgoingLinkPayload<ExtArgs>, T, "findMany"> | Null>
    bagsFromIncoming<T extends OutgoingFlight$bagsFromIncomingArgs<ExtArgs> = {}>(args?: Subset<T, OutgoingFlight$bagsFromIncomingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BagAssignmentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OutgoingFlight model
   */ 
  interface OutgoingFlightFieldRefs {
    readonly id: FieldRef<"OutgoingFlight", 'String'>
    readonly flightNumber: FieldRef<"OutgoingFlight", 'String'>
    readonly terminal: FieldRef<"OutgoingFlight", 'String'>
    readonly destination: FieldRef<"OutgoingFlight", 'String'>
    readonly scheduledTime: FieldRef<"OutgoingFlight", 'DateTime'>
    readonly actualTime: FieldRef<"OutgoingFlight", 'DateTime'>
    readonly expectedTime: FieldRef<"OutgoingFlight", 'DateTime'>
    readonly cancelled: FieldRef<"OutgoingFlight", 'Boolean'>
    readonly createdAt: FieldRef<"OutgoingFlight", 'DateTime'>
    readonly updatedAt: FieldRef<"OutgoingFlight", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OutgoingFlight findUnique
   */
  export type OutgoingFlightFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutgoingFlight
     */
    select?: OutgoingFlightSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutgoingFlightInclude<ExtArgs> | null
    /**
     * Filter, which OutgoingFlight to fetch.
     */
    where: OutgoingFlightWhereUniqueInput
  }

  /**
   * OutgoingFlight findUniqueOrThrow
   */
  export type OutgoingFlightFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutgoingFlight
     */
    select?: OutgoingFlightSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutgoingFlightInclude<ExtArgs> | null
    /**
     * Filter, which OutgoingFlight to fetch.
     */
    where: OutgoingFlightWhereUniqueInput
  }

  /**
   * OutgoingFlight findFirst
   */
  export type OutgoingFlightFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutgoingFlight
     */
    select?: OutgoingFlightSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutgoingFlightInclude<ExtArgs> | null
    /**
     * Filter, which OutgoingFlight to fetch.
     */
    where?: OutgoingFlightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OutgoingFlights to fetch.
     */
    orderBy?: OutgoingFlightOrderByWithRelationInput | OutgoingFlightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OutgoingFlights.
     */
    cursor?: OutgoingFlightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OutgoingFlights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OutgoingFlights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OutgoingFlights.
     */
    distinct?: OutgoingFlightScalarFieldEnum | OutgoingFlightScalarFieldEnum[]
  }

  /**
   * OutgoingFlight findFirstOrThrow
   */
  export type OutgoingFlightFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutgoingFlight
     */
    select?: OutgoingFlightSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutgoingFlightInclude<ExtArgs> | null
    /**
     * Filter, which OutgoingFlight to fetch.
     */
    where?: OutgoingFlightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OutgoingFlights to fetch.
     */
    orderBy?: OutgoingFlightOrderByWithRelationInput | OutgoingFlightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OutgoingFlights.
     */
    cursor?: OutgoingFlightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OutgoingFlights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OutgoingFlights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OutgoingFlights.
     */
    distinct?: OutgoingFlightScalarFieldEnum | OutgoingFlightScalarFieldEnum[]
  }

  /**
   * OutgoingFlight findMany
   */
  export type OutgoingFlightFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutgoingFlight
     */
    select?: OutgoingFlightSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutgoingFlightInclude<ExtArgs> | null
    /**
     * Filter, which OutgoingFlights to fetch.
     */
    where?: OutgoingFlightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OutgoingFlights to fetch.
     */
    orderBy?: OutgoingFlightOrderByWithRelationInput | OutgoingFlightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OutgoingFlights.
     */
    cursor?: OutgoingFlightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OutgoingFlights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OutgoingFlights.
     */
    skip?: number
    distinct?: OutgoingFlightScalarFieldEnum | OutgoingFlightScalarFieldEnum[]
  }

  /**
   * OutgoingFlight create
   */
  export type OutgoingFlightCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutgoingFlight
     */
    select?: OutgoingFlightSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutgoingFlightInclude<ExtArgs> | null
    /**
     * The data needed to create a OutgoingFlight.
     */
    data: XOR<OutgoingFlightCreateInput, OutgoingFlightUncheckedCreateInput>
  }

  /**
   * OutgoingFlight createMany
   */
  export type OutgoingFlightCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OutgoingFlights.
     */
    data: OutgoingFlightCreateManyInput | OutgoingFlightCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OutgoingFlight createManyAndReturn
   */
  export type OutgoingFlightCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutgoingFlight
     */
    select?: OutgoingFlightSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many OutgoingFlights.
     */
    data: OutgoingFlightCreateManyInput | OutgoingFlightCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OutgoingFlight update
   */
  export type OutgoingFlightUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutgoingFlight
     */
    select?: OutgoingFlightSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutgoingFlightInclude<ExtArgs> | null
    /**
     * The data needed to update a OutgoingFlight.
     */
    data: XOR<OutgoingFlightUpdateInput, OutgoingFlightUncheckedUpdateInput>
    /**
     * Choose, which OutgoingFlight to update.
     */
    where: OutgoingFlightWhereUniqueInput
  }

  /**
   * OutgoingFlight updateMany
   */
  export type OutgoingFlightUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OutgoingFlights.
     */
    data: XOR<OutgoingFlightUpdateManyMutationInput, OutgoingFlightUncheckedUpdateManyInput>
    /**
     * Filter which OutgoingFlights to update
     */
    where?: OutgoingFlightWhereInput
  }

  /**
   * OutgoingFlight upsert
   */
  export type OutgoingFlightUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutgoingFlight
     */
    select?: OutgoingFlightSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutgoingFlightInclude<ExtArgs> | null
    /**
     * The filter to search for the OutgoingFlight to update in case it exists.
     */
    where: OutgoingFlightWhereUniqueInput
    /**
     * In case the OutgoingFlight found by the `where` argument doesn't exist, create a new OutgoingFlight with this data.
     */
    create: XOR<OutgoingFlightCreateInput, OutgoingFlightUncheckedCreateInput>
    /**
     * In case the OutgoingFlight was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OutgoingFlightUpdateInput, OutgoingFlightUncheckedUpdateInput>
  }

  /**
   * OutgoingFlight delete
   */
  export type OutgoingFlightDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutgoingFlight
     */
    select?: OutgoingFlightSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutgoingFlightInclude<ExtArgs> | null
    /**
     * Filter which OutgoingFlight to delete.
     */
    where: OutgoingFlightWhereUniqueInput
  }

  /**
   * OutgoingFlight deleteMany
   */
  export type OutgoingFlightDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OutgoingFlights to delete
     */
    where?: OutgoingFlightWhereInput
  }

  /**
   * OutgoingFlight.incomingLinks
   */
  export type OutgoingFlight$incomingLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutgoingLink
     */
    select?: OutgoingLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutgoingLinkInclude<ExtArgs> | null
    where?: OutgoingLinkWhereInput
    orderBy?: OutgoingLinkOrderByWithRelationInput | OutgoingLinkOrderByWithRelationInput[]
    cursor?: OutgoingLinkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OutgoingLinkScalarFieldEnum | OutgoingLinkScalarFieldEnum[]
  }

  /**
   * OutgoingFlight.bagsFromIncoming
   */
  export type OutgoingFlight$bagsFromIncomingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BagAssignment
     */
    select?: BagAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BagAssignmentInclude<ExtArgs> | null
    where?: BagAssignmentWhereInput
    orderBy?: BagAssignmentOrderByWithRelationInput | BagAssignmentOrderByWithRelationInput[]
    cursor?: BagAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BagAssignmentScalarFieldEnum | BagAssignmentScalarFieldEnum[]
  }

  /**
   * OutgoingFlight without action
   */
  export type OutgoingFlightDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutgoingFlight
     */
    select?: OutgoingFlightSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutgoingFlightInclude<ExtArgs> | null
  }


  /**
   * Model OutgoingLink
   */

  export type AggregateOutgoingLink = {
    _count: OutgoingLinkCountAggregateOutputType | null
    _avg: OutgoingLinkAvgAggregateOutputType | null
    _sum: OutgoingLinkSumAggregateOutputType | null
    _min: OutgoingLinkMinAggregateOutputType | null
    _max: OutgoingLinkMaxAggregateOutputType | null
  }

  export type OutgoingLinkAvgAggregateOutputType = {
    bagCount: number | null
  }

  export type OutgoingLinkSumAggregateOutputType = {
    bagCount: number | null
  }

  export type OutgoingLinkMinAggregateOutputType = {
    id: string | null
    incomingFlightId: string | null
    outgoingFlightId: string | null
    bagCount: number | null
    isMAGTransfer: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OutgoingLinkMaxAggregateOutputType = {
    id: string | null
    incomingFlightId: string | null
    outgoingFlightId: string | null
    bagCount: number | null
    isMAGTransfer: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OutgoingLinkCountAggregateOutputType = {
    id: number
    incomingFlightId: number
    outgoingFlightId: number
    bagCount: number
    isMAGTransfer: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OutgoingLinkAvgAggregateInputType = {
    bagCount?: true
  }

  export type OutgoingLinkSumAggregateInputType = {
    bagCount?: true
  }

  export type OutgoingLinkMinAggregateInputType = {
    id?: true
    incomingFlightId?: true
    outgoingFlightId?: true
    bagCount?: true
    isMAGTransfer?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OutgoingLinkMaxAggregateInputType = {
    id?: true
    incomingFlightId?: true
    outgoingFlightId?: true
    bagCount?: true
    isMAGTransfer?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OutgoingLinkCountAggregateInputType = {
    id?: true
    incomingFlightId?: true
    outgoingFlightId?: true
    bagCount?: true
    isMAGTransfer?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OutgoingLinkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OutgoingLink to aggregate.
     */
    where?: OutgoingLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OutgoingLinks to fetch.
     */
    orderBy?: OutgoingLinkOrderByWithRelationInput | OutgoingLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OutgoingLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OutgoingLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OutgoingLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OutgoingLinks
    **/
    _count?: true | OutgoingLinkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OutgoingLinkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OutgoingLinkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OutgoingLinkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OutgoingLinkMaxAggregateInputType
  }

  export type GetOutgoingLinkAggregateType<T extends OutgoingLinkAggregateArgs> = {
        [P in keyof T & keyof AggregateOutgoingLink]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOutgoingLink[P]>
      : GetScalarType<T[P], AggregateOutgoingLink[P]>
  }




  export type OutgoingLinkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OutgoingLinkWhereInput
    orderBy?: OutgoingLinkOrderByWithAggregationInput | OutgoingLinkOrderByWithAggregationInput[]
    by: OutgoingLinkScalarFieldEnum[] | OutgoingLinkScalarFieldEnum
    having?: OutgoingLinkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OutgoingLinkCountAggregateInputType | true
    _avg?: OutgoingLinkAvgAggregateInputType
    _sum?: OutgoingLinkSumAggregateInputType
    _min?: OutgoingLinkMinAggregateInputType
    _max?: OutgoingLinkMaxAggregateInputType
  }

  export type OutgoingLinkGroupByOutputType = {
    id: string
    incomingFlightId: string
    outgoingFlightId: string
    bagCount: number
    isMAGTransfer: boolean
    createdAt: Date
    updatedAt: Date
    _count: OutgoingLinkCountAggregateOutputType | null
    _avg: OutgoingLinkAvgAggregateOutputType | null
    _sum: OutgoingLinkSumAggregateOutputType | null
    _min: OutgoingLinkMinAggregateOutputType | null
    _max: OutgoingLinkMaxAggregateOutputType | null
  }

  type GetOutgoingLinkGroupByPayload<T extends OutgoingLinkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OutgoingLinkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OutgoingLinkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OutgoingLinkGroupByOutputType[P]>
            : GetScalarType<T[P], OutgoingLinkGroupByOutputType[P]>
        }
      >
    >


  export type OutgoingLinkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    incomingFlightId?: boolean
    outgoingFlightId?: boolean
    bagCount?: boolean
    isMAGTransfer?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    incomingFlight?: boolean | IncomingFlightDefaultArgs<ExtArgs>
    outgoingFlight?: boolean | OutgoingFlightDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["outgoingLink"]>

  export type OutgoingLinkSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    incomingFlightId?: boolean
    outgoingFlightId?: boolean
    bagCount?: boolean
    isMAGTransfer?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    incomingFlight?: boolean | IncomingFlightDefaultArgs<ExtArgs>
    outgoingFlight?: boolean | OutgoingFlightDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["outgoingLink"]>

  export type OutgoingLinkSelectScalar = {
    id?: boolean
    incomingFlightId?: boolean
    outgoingFlightId?: boolean
    bagCount?: boolean
    isMAGTransfer?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OutgoingLinkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    incomingFlight?: boolean | IncomingFlightDefaultArgs<ExtArgs>
    outgoingFlight?: boolean | OutgoingFlightDefaultArgs<ExtArgs>
  }
  export type OutgoingLinkIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    incomingFlight?: boolean | IncomingFlightDefaultArgs<ExtArgs>
    outgoingFlight?: boolean | OutgoingFlightDefaultArgs<ExtArgs>
  }

  export type $OutgoingLinkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OutgoingLink"
    objects: {
      incomingFlight: Prisma.$IncomingFlightPayload<ExtArgs>
      outgoingFlight: Prisma.$OutgoingFlightPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      incomingFlightId: string
      outgoingFlightId: string
      bagCount: number
      isMAGTransfer: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["outgoingLink"]>
    composites: {}
  }

  type OutgoingLinkGetPayload<S extends boolean | null | undefined | OutgoingLinkDefaultArgs> = $Result.GetResult<Prisma.$OutgoingLinkPayload, S>

  type OutgoingLinkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OutgoingLinkFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OutgoingLinkCountAggregateInputType | true
    }

  export interface OutgoingLinkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OutgoingLink'], meta: { name: 'OutgoingLink' } }
    /**
     * Find zero or one OutgoingLink that matches the filter.
     * @param {OutgoingLinkFindUniqueArgs} args - Arguments to find a OutgoingLink
     * @example
     * // Get one OutgoingLink
     * const outgoingLink = await prisma.outgoingLink.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OutgoingLinkFindUniqueArgs>(args: SelectSubset<T, OutgoingLinkFindUniqueArgs<ExtArgs>>): Prisma__OutgoingLinkClient<$Result.GetResult<Prisma.$OutgoingLinkPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one OutgoingLink that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OutgoingLinkFindUniqueOrThrowArgs} args - Arguments to find a OutgoingLink
     * @example
     * // Get one OutgoingLink
     * const outgoingLink = await prisma.outgoingLink.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OutgoingLinkFindUniqueOrThrowArgs>(args: SelectSubset<T, OutgoingLinkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OutgoingLinkClient<$Result.GetResult<Prisma.$OutgoingLinkPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first OutgoingLink that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutgoingLinkFindFirstArgs} args - Arguments to find a OutgoingLink
     * @example
     * // Get one OutgoingLink
     * const outgoingLink = await prisma.outgoingLink.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OutgoingLinkFindFirstArgs>(args?: SelectSubset<T, OutgoingLinkFindFirstArgs<ExtArgs>>): Prisma__OutgoingLinkClient<$Result.GetResult<Prisma.$OutgoingLinkPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first OutgoingLink that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutgoingLinkFindFirstOrThrowArgs} args - Arguments to find a OutgoingLink
     * @example
     * // Get one OutgoingLink
     * const outgoingLink = await prisma.outgoingLink.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OutgoingLinkFindFirstOrThrowArgs>(args?: SelectSubset<T, OutgoingLinkFindFirstOrThrowArgs<ExtArgs>>): Prisma__OutgoingLinkClient<$Result.GetResult<Prisma.$OutgoingLinkPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more OutgoingLinks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutgoingLinkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OutgoingLinks
     * const outgoingLinks = await prisma.outgoingLink.findMany()
     * 
     * // Get first 10 OutgoingLinks
     * const outgoingLinks = await prisma.outgoingLink.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const outgoingLinkWithIdOnly = await prisma.outgoingLink.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OutgoingLinkFindManyArgs>(args?: SelectSubset<T, OutgoingLinkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OutgoingLinkPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a OutgoingLink.
     * @param {OutgoingLinkCreateArgs} args - Arguments to create a OutgoingLink.
     * @example
     * // Create one OutgoingLink
     * const OutgoingLink = await prisma.outgoingLink.create({
     *   data: {
     *     // ... data to create a OutgoingLink
     *   }
     * })
     * 
     */
    create<T extends OutgoingLinkCreateArgs>(args: SelectSubset<T, OutgoingLinkCreateArgs<ExtArgs>>): Prisma__OutgoingLinkClient<$Result.GetResult<Prisma.$OutgoingLinkPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many OutgoingLinks.
     * @param {OutgoingLinkCreateManyArgs} args - Arguments to create many OutgoingLinks.
     * @example
     * // Create many OutgoingLinks
     * const outgoingLink = await prisma.outgoingLink.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OutgoingLinkCreateManyArgs>(args?: SelectSubset<T, OutgoingLinkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OutgoingLinks and returns the data saved in the database.
     * @param {OutgoingLinkCreateManyAndReturnArgs} args - Arguments to create many OutgoingLinks.
     * @example
     * // Create many OutgoingLinks
     * const outgoingLink = await prisma.outgoingLink.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OutgoingLinks and only return the `id`
     * const outgoingLinkWithIdOnly = await prisma.outgoingLink.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OutgoingLinkCreateManyAndReturnArgs>(args?: SelectSubset<T, OutgoingLinkCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OutgoingLinkPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a OutgoingLink.
     * @param {OutgoingLinkDeleteArgs} args - Arguments to delete one OutgoingLink.
     * @example
     * // Delete one OutgoingLink
     * const OutgoingLink = await prisma.outgoingLink.delete({
     *   where: {
     *     // ... filter to delete one OutgoingLink
     *   }
     * })
     * 
     */
    delete<T extends OutgoingLinkDeleteArgs>(args: SelectSubset<T, OutgoingLinkDeleteArgs<ExtArgs>>): Prisma__OutgoingLinkClient<$Result.GetResult<Prisma.$OutgoingLinkPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one OutgoingLink.
     * @param {OutgoingLinkUpdateArgs} args - Arguments to update one OutgoingLink.
     * @example
     * // Update one OutgoingLink
     * const outgoingLink = await prisma.outgoingLink.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OutgoingLinkUpdateArgs>(args: SelectSubset<T, OutgoingLinkUpdateArgs<ExtArgs>>): Prisma__OutgoingLinkClient<$Result.GetResult<Prisma.$OutgoingLinkPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more OutgoingLinks.
     * @param {OutgoingLinkDeleteManyArgs} args - Arguments to filter OutgoingLinks to delete.
     * @example
     * // Delete a few OutgoingLinks
     * const { count } = await prisma.outgoingLink.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OutgoingLinkDeleteManyArgs>(args?: SelectSubset<T, OutgoingLinkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OutgoingLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutgoingLinkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OutgoingLinks
     * const outgoingLink = await prisma.outgoingLink.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OutgoingLinkUpdateManyArgs>(args: SelectSubset<T, OutgoingLinkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OutgoingLink.
     * @param {OutgoingLinkUpsertArgs} args - Arguments to update or create a OutgoingLink.
     * @example
     * // Update or create a OutgoingLink
     * const outgoingLink = await prisma.outgoingLink.upsert({
     *   create: {
     *     // ... data to create a OutgoingLink
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OutgoingLink we want to update
     *   }
     * })
     */
    upsert<T extends OutgoingLinkUpsertArgs>(args: SelectSubset<T, OutgoingLinkUpsertArgs<ExtArgs>>): Prisma__OutgoingLinkClient<$Result.GetResult<Prisma.$OutgoingLinkPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of OutgoingLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutgoingLinkCountArgs} args - Arguments to filter OutgoingLinks to count.
     * @example
     * // Count the number of OutgoingLinks
     * const count = await prisma.outgoingLink.count({
     *   where: {
     *     // ... the filter for the OutgoingLinks we want to count
     *   }
     * })
    **/
    count<T extends OutgoingLinkCountArgs>(
      args?: Subset<T, OutgoingLinkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OutgoingLinkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OutgoingLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutgoingLinkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OutgoingLinkAggregateArgs>(args: Subset<T, OutgoingLinkAggregateArgs>): Prisma.PrismaPromise<GetOutgoingLinkAggregateType<T>>

    /**
     * Group by OutgoingLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutgoingLinkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OutgoingLinkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OutgoingLinkGroupByArgs['orderBy'] }
        : { orderBy?: OutgoingLinkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OutgoingLinkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOutgoingLinkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OutgoingLink model
   */
  readonly fields: OutgoingLinkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OutgoingLink.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OutgoingLinkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    incomingFlight<T extends IncomingFlightDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IncomingFlightDefaultArgs<ExtArgs>>): Prisma__IncomingFlightClient<$Result.GetResult<Prisma.$IncomingFlightPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    outgoingFlight<T extends OutgoingFlightDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OutgoingFlightDefaultArgs<ExtArgs>>): Prisma__OutgoingFlightClient<$Result.GetResult<Prisma.$OutgoingFlightPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OutgoingLink model
   */ 
  interface OutgoingLinkFieldRefs {
    readonly id: FieldRef<"OutgoingLink", 'String'>
    readonly incomingFlightId: FieldRef<"OutgoingLink", 'String'>
    readonly outgoingFlightId: FieldRef<"OutgoingLink", 'String'>
    readonly bagCount: FieldRef<"OutgoingLink", 'Int'>
    readonly isMAGTransfer: FieldRef<"OutgoingLink", 'Boolean'>
    readonly createdAt: FieldRef<"OutgoingLink", 'DateTime'>
    readonly updatedAt: FieldRef<"OutgoingLink", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OutgoingLink findUnique
   */
  export type OutgoingLinkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutgoingLink
     */
    select?: OutgoingLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutgoingLinkInclude<ExtArgs> | null
    /**
     * Filter, which OutgoingLink to fetch.
     */
    where: OutgoingLinkWhereUniqueInput
  }

  /**
   * OutgoingLink findUniqueOrThrow
   */
  export type OutgoingLinkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutgoingLink
     */
    select?: OutgoingLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutgoingLinkInclude<ExtArgs> | null
    /**
     * Filter, which OutgoingLink to fetch.
     */
    where: OutgoingLinkWhereUniqueInput
  }

  /**
   * OutgoingLink findFirst
   */
  export type OutgoingLinkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutgoingLink
     */
    select?: OutgoingLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutgoingLinkInclude<ExtArgs> | null
    /**
     * Filter, which OutgoingLink to fetch.
     */
    where?: OutgoingLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OutgoingLinks to fetch.
     */
    orderBy?: OutgoingLinkOrderByWithRelationInput | OutgoingLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OutgoingLinks.
     */
    cursor?: OutgoingLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OutgoingLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OutgoingLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OutgoingLinks.
     */
    distinct?: OutgoingLinkScalarFieldEnum | OutgoingLinkScalarFieldEnum[]
  }

  /**
   * OutgoingLink findFirstOrThrow
   */
  export type OutgoingLinkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutgoingLink
     */
    select?: OutgoingLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutgoingLinkInclude<ExtArgs> | null
    /**
     * Filter, which OutgoingLink to fetch.
     */
    where?: OutgoingLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OutgoingLinks to fetch.
     */
    orderBy?: OutgoingLinkOrderByWithRelationInput | OutgoingLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OutgoingLinks.
     */
    cursor?: OutgoingLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OutgoingLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OutgoingLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OutgoingLinks.
     */
    distinct?: OutgoingLinkScalarFieldEnum | OutgoingLinkScalarFieldEnum[]
  }

  /**
   * OutgoingLink findMany
   */
  export type OutgoingLinkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutgoingLink
     */
    select?: OutgoingLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutgoingLinkInclude<ExtArgs> | null
    /**
     * Filter, which OutgoingLinks to fetch.
     */
    where?: OutgoingLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OutgoingLinks to fetch.
     */
    orderBy?: OutgoingLinkOrderByWithRelationInput | OutgoingLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OutgoingLinks.
     */
    cursor?: OutgoingLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OutgoingLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OutgoingLinks.
     */
    skip?: number
    distinct?: OutgoingLinkScalarFieldEnum | OutgoingLinkScalarFieldEnum[]
  }

  /**
   * OutgoingLink create
   */
  export type OutgoingLinkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutgoingLink
     */
    select?: OutgoingLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutgoingLinkInclude<ExtArgs> | null
    /**
     * The data needed to create a OutgoingLink.
     */
    data: XOR<OutgoingLinkCreateInput, OutgoingLinkUncheckedCreateInput>
  }

  /**
   * OutgoingLink createMany
   */
  export type OutgoingLinkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OutgoingLinks.
     */
    data: OutgoingLinkCreateManyInput | OutgoingLinkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OutgoingLink createManyAndReturn
   */
  export type OutgoingLinkCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutgoingLink
     */
    select?: OutgoingLinkSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many OutgoingLinks.
     */
    data: OutgoingLinkCreateManyInput | OutgoingLinkCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutgoingLinkIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OutgoingLink update
   */
  export type OutgoingLinkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutgoingLink
     */
    select?: OutgoingLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutgoingLinkInclude<ExtArgs> | null
    /**
     * The data needed to update a OutgoingLink.
     */
    data: XOR<OutgoingLinkUpdateInput, OutgoingLinkUncheckedUpdateInput>
    /**
     * Choose, which OutgoingLink to update.
     */
    where: OutgoingLinkWhereUniqueInput
  }

  /**
   * OutgoingLink updateMany
   */
  export type OutgoingLinkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OutgoingLinks.
     */
    data: XOR<OutgoingLinkUpdateManyMutationInput, OutgoingLinkUncheckedUpdateManyInput>
    /**
     * Filter which OutgoingLinks to update
     */
    where?: OutgoingLinkWhereInput
  }

  /**
   * OutgoingLink upsert
   */
  export type OutgoingLinkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutgoingLink
     */
    select?: OutgoingLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutgoingLinkInclude<ExtArgs> | null
    /**
     * The filter to search for the OutgoingLink to update in case it exists.
     */
    where: OutgoingLinkWhereUniqueInput
    /**
     * In case the OutgoingLink found by the `where` argument doesn't exist, create a new OutgoingLink with this data.
     */
    create: XOR<OutgoingLinkCreateInput, OutgoingLinkUncheckedCreateInput>
    /**
     * In case the OutgoingLink was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OutgoingLinkUpdateInput, OutgoingLinkUncheckedUpdateInput>
  }

  /**
   * OutgoingLink delete
   */
  export type OutgoingLinkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutgoingLink
     */
    select?: OutgoingLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutgoingLinkInclude<ExtArgs> | null
    /**
     * Filter which OutgoingLink to delete.
     */
    where: OutgoingLinkWhereUniqueInput
  }

  /**
   * OutgoingLink deleteMany
   */
  export type OutgoingLinkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OutgoingLinks to delete
     */
    where?: OutgoingLinkWhereInput
  }

  /**
   * OutgoingLink without action
   */
  export type OutgoingLinkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OutgoingLink
     */
    select?: OutgoingLinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutgoingLinkInclude<ExtArgs> | null
  }


  /**
   * Model BagAssignment
   */

  export type AggregateBagAssignment = {
    _count: BagAssignmentCountAggregateOutputType | null
    _avg: BagAssignmentAvgAggregateOutputType | null
    _sum: BagAssignmentSumAggregateOutputType | null
    _min: BagAssignmentMinAggregateOutputType | null
    _max: BagAssignmentMaxAggregateOutputType | null
  }

  export type BagAssignmentAvgAggregateOutputType = {
    bagCount: number | null
  }

  export type BagAssignmentSumAggregateOutputType = {
    bagCount: number | null
  }

  export type BagAssignmentMinAggregateOutputType = {
    id: string | null
    outgoingFlightId: string | null
    incomingFlightNumber: string | null
    bagCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BagAssignmentMaxAggregateOutputType = {
    id: string | null
    outgoingFlightId: string | null
    incomingFlightNumber: string | null
    bagCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BagAssignmentCountAggregateOutputType = {
    id: number
    outgoingFlightId: number
    incomingFlightNumber: number
    bagCount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BagAssignmentAvgAggregateInputType = {
    bagCount?: true
  }

  export type BagAssignmentSumAggregateInputType = {
    bagCount?: true
  }

  export type BagAssignmentMinAggregateInputType = {
    id?: true
    outgoingFlightId?: true
    incomingFlightNumber?: true
    bagCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BagAssignmentMaxAggregateInputType = {
    id?: true
    outgoingFlightId?: true
    incomingFlightNumber?: true
    bagCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BagAssignmentCountAggregateInputType = {
    id?: true
    outgoingFlightId?: true
    incomingFlightNumber?: true
    bagCount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BagAssignmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BagAssignment to aggregate.
     */
    where?: BagAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BagAssignments to fetch.
     */
    orderBy?: BagAssignmentOrderByWithRelationInput | BagAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BagAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BagAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BagAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BagAssignments
    **/
    _count?: true | BagAssignmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BagAssignmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BagAssignmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BagAssignmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BagAssignmentMaxAggregateInputType
  }

  export type GetBagAssignmentAggregateType<T extends BagAssignmentAggregateArgs> = {
        [P in keyof T & keyof AggregateBagAssignment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBagAssignment[P]>
      : GetScalarType<T[P], AggregateBagAssignment[P]>
  }




  export type BagAssignmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BagAssignmentWhereInput
    orderBy?: BagAssignmentOrderByWithAggregationInput | BagAssignmentOrderByWithAggregationInput[]
    by: BagAssignmentScalarFieldEnum[] | BagAssignmentScalarFieldEnum
    having?: BagAssignmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BagAssignmentCountAggregateInputType | true
    _avg?: BagAssignmentAvgAggregateInputType
    _sum?: BagAssignmentSumAggregateInputType
    _min?: BagAssignmentMinAggregateInputType
    _max?: BagAssignmentMaxAggregateInputType
  }

  export type BagAssignmentGroupByOutputType = {
    id: string
    outgoingFlightId: string
    incomingFlightNumber: string
    bagCount: number
    createdAt: Date
    updatedAt: Date
    _count: BagAssignmentCountAggregateOutputType | null
    _avg: BagAssignmentAvgAggregateOutputType | null
    _sum: BagAssignmentSumAggregateOutputType | null
    _min: BagAssignmentMinAggregateOutputType | null
    _max: BagAssignmentMaxAggregateOutputType | null
  }

  type GetBagAssignmentGroupByPayload<T extends BagAssignmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BagAssignmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BagAssignmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BagAssignmentGroupByOutputType[P]>
            : GetScalarType<T[P], BagAssignmentGroupByOutputType[P]>
        }
      >
    >


  export type BagAssignmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    outgoingFlightId?: boolean
    incomingFlightNumber?: boolean
    bagCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    outgoingFlight?: boolean | OutgoingFlightDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bagAssignment"]>

  export type BagAssignmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    outgoingFlightId?: boolean
    incomingFlightNumber?: boolean
    bagCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    outgoingFlight?: boolean | OutgoingFlightDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bagAssignment"]>

  export type BagAssignmentSelectScalar = {
    id?: boolean
    outgoingFlightId?: boolean
    incomingFlightNumber?: boolean
    bagCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BagAssignmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    outgoingFlight?: boolean | OutgoingFlightDefaultArgs<ExtArgs>
  }
  export type BagAssignmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    outgoingFlight?: boolean | OutgoingFlightDefaultArgs<ExtArgs>
  }

  export type $BagAssignmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BagAssignment"
    objects: {
      outgoingFlight: Prisma.$OutgoingFlightPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      outgoingFlightId: string
      incomingFlightNumber: string
      bagCount: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["bagAssignment"]>
    composites: {}
  }

  type BagAssignmentGetPayload<S extends boolean | null | undefined | BagAssignmentDefaultArgs> = $Result.GetResult<Prisma.$BagAssignmentPayload, S>

  type BagAssignmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BagAssignmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BagAssignmentCountAggregateInputType | true
    }

  export interface BagAssignmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BagAssignment'], meta: { name: 'BagAssignment' } }
    /**
     * Find zero or one BagAssignment that matches the filter.
     * @param {BagAssignmentFindUniqueArgs} args - Arguments to find a BagAssignment
     * @example
     * // Get one BagAssignment
     * const bagAssignment = await prisma.bagAssignment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BagAssignmentFindUniqueArgs>(args: SelectSubset<T, BagAssignmentFindUniqueArgs<ExtArgs>>): Prisma__BagAssignmentClient<$Result.GetResult<Prisma.$BagAssignmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BagAssignment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BagAssignmentFindUniqueOrThrowArgs} args - Arguments to find a BagAssignment
     * @example
     * // Get one BagAssignment
     * const bagAssignment = await prisma.bagAssignment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BagAssignmentFindUniqueOrThrowArgs>(args: SelectSubset<T, BagAssignmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BagAssignmentClient<$Result.GetResult<Prisma.$BagAssignmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BagAssignment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BagAssignmentFindFirstArgs} args - Arguments to find a BagAssignment
     * @example
     * // Get one BagAssignment
     * const bagAssignment = await prisma.bagAssignment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BagAssignmentFindFirstArgs>(args?: SelectSubset<T, BagAssignmentFindFirstArgs<ExtArgs>>): Prisma__BagAssignmentClient<$Result.GetResult<Prisma.$BagAssignmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BagAssignment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BagAssignmentFindFirstOrThrowArgs} args - Arguments to find a BagAssignment
     * @example
     * // Get one BagAssignment
     * const bagAssignment = await prisma.bagAssignment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BagAssignmentFindFirstOrThrowArgs>(args?: SelectSubset<T, BagAssignmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__BagAssignmentClient<$Result.GetResult<Prisma.$BagAssignmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BagAssignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BagAssignmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BagAssignments
     * const bagAssignments = await prisma.bagAssignment.findMany()
     * 
     * // Get first 10 BagAssignments
     * const bagAssignments = await prisma.bagAssignment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bagAssignmentWithIdOnly = await prisma.bagAssignment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BagAssignmentFindManyArgs>(args?: SelectSubset<T, BagAssignmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BagAssignmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BagAssignment.
     * @param {BagAssignmentCreateArgs} args - Arguments to create a BagAssignment.
     * @example
     * // Create one BagAssignment
     * const BagAssignment = await prisma.bagAssignment.create({
     *   data: {
     *     // ... data to create a BagAssignment
     *   }
     * })
     * 
     */
    create<T extends BagAssignmentCreateArgs>(args: SelectSubset<T, BagAssignmentCreateArgs<ExtArgs>>): Prisma__BagAssignmentClient<$Result.GetResult<Prisma.$BagAssignmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BagAssignments.
     * @param {BagAssignmentCreateManyArgs} args - Arguments to create many BagAssignments.
     * @example
     * // Create many BagAssignments
     * const bagAssignment = await prisma.bagAssignment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BagAssignmentCreateManyArgs>(args?: SelectSubset<T, BagAssignmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BagAssignments and returns the data saved in the database.
     * @param {BagAssignmentCreateManyAndReturnArgs} args - Arguments to create many BagAssignments.
     * @example
     * // Create many BagAssignments
     * const bagAssignment = await prisma.bagAssignment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BagAssignments and only return the `id`
     * const bagAssignmentWithIdOnly = await prisma.bagAssignment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BagAssignmentCreateManyAndReturnArgs>(args?: SelectSubset<T, BagAssignmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BagAssignmentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BagAssignment.
     * @param {BagAssignmentDeleteArgs} args - Arguments to delete one BagAssignment.
     * @example
     * // Delete one BagAssignment
     * const BagAssignment = await prisma.bagAssignment.delete({
     *   where: {
     *     // ... filter to delete one BagAssignment
     *   }
     * })
     * 
     */
    delete<T extends BagAssignmentDeleteArgs>(args: SelectSubset<T, BagAssignmentDeleteArgs<ExtArgs>>): Prisma__BagAssignmentClient<$Result.GetResult<Prisma.$BagAssignmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BagAssignment.
     * @param {BagAssignmentUpdateArgs} args - Arguments to update one BagAssignment.
     * @example
     * // Update one BagAssignment
     * const bagAssignment = await prisma.bagAssignment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BagAssignmentUpdateArgs>(args: SelectSubset<T, BagAssignmentUpdateArgs<ExtArgs>>): Prisma__BagAssignmentClient<$Result.GetResult<Prisma.$BagAssignmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BagAssignments.
     * @param {BagAssignmentDeleteManyArgs} args - Arguments to filter BagAssignments to delete.
     * @example
     * // Delete a few BagAssignments
     * const { count } = await prisma.bagAssignment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BagAssignmentDeleteManyArgs>(args?: SelectSubset<T, BagAssignmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BagAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BagAssignmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BagAssignments
     * const bagAssignment = await prisma.bagAssignment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BagAssignmentUpdateManyArgs>(args: SelectSubset<T, BagAssignmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BagAssignment.
     * @param {BagAssignmentUpsertArgs} args - Arguments to update or create a BagAssignment.
     * @example
     * // Update or create a BagAssignment
     * const bagAssignment = await prisma.bagAssignment.upsert({
     *   create: {
     *     // ... data to create a BagAssignment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BagAssignment we want to update
     *   }
     * })
     */
    upsert<T extends BagAssignmentUpsertArgs>(args: SelectSubset<T, BagAssignmentUpsertArgs<ExtArgs>>): Prisma__BagAssignmentClient<$Result.GetResult<Prisma.$BagAssignmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BagAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BagAssignmentCountArgs} args - Arguments to filter BagAssignments to count.
     * @example
     * // Count the number of BagAssignments
     * const count = await prisma.bagAssignment.count({
     *   where: {
     *     // ... the filter for the BagAssignments we want to count
     *   }
     * })
    **/
    count<T extends BagAssignmentCountArgs>(
      args?: Subset<T, BagAssignmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BagAssignmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BagAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BagAssignmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BagAssignmentAggregateArgs>(args: Subset<T, BagAssignmentAggregateArgs>): Prisma.PrismaPromise<GetBagAssignmentAggregateType<T>>

    /**
     * Group by BagAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BagAssignmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BagAssignmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BagAssignmentGroupByArgs['orderBy'] }
        : { orderBy?: BagAssignmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BagAssignmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBagAssignmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BagAssignment model
   */
  readonly fields: BagAssignmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BagAssignment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BagAssignmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    outgoingFlight<T extends OutgoingFlightDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OutgoingFlightDefaultArgs<ExtArgs>>): Prisma__OutgoingFlightClient<$Result.GetResult<Prisma.$OutgoingFlightPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BagAssignment model
   */ 
  interface BagAssignmentFieldRefs {
    readonly id: FieldRef<"BagAssignment", 'String'>
    readonly outgoingFlightId: FieldRef<"BagAssignment", 'String'>
    readonly incomingFlightNumber: FieldRef<"BagAssignment", 'String'>
    readonly bagCount: FieldRef<"BagAssignment", 'Int'>
    readonly createdAt: FieldRef<"BagAssignment", 'DateTime'>
    readonly updatedAt: FieldRef<"BagAssignment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BagAssignment findUnique
   */
  export type BagAssignmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BagAssignment
     */
    select?: BagAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BagAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which BagAssignment to fetch.
     */
    where: BagAssignmentWhereUniqueInput
  }

  /**
   * BagAssignment findUniqueOrThrow
   */
  export type BagAssignmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BagAssignment
     */
    select?: BagAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BagAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which BagAssignment to fetch.
     */
    where: BagAssignmentWhereUniqueInput
  }

  /**
   * BagAssignment findFirst
   */
  export type BagAssignmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BagAssignment
     */
    select?: BagAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BagAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which BagAssignment to fetch.
     */
    where?: BagAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BagAssignments to fetch.
     */
    orderBy?: BagAssignmentOrderByWithRelationInput | BagAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BagAssignments.
     */
    cursor?: BagAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BagAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BagAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BagAssignments.
     */
    distinct?: BagAssignmentScalarFieldEnum | BagAssignmentScalarFieldEnum[]
  }

  /**
   * BagAssignment findFirstOrThrow
   */
  export type BagAssignmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BagAssignment
     */
    select?: BagAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BagAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which BagAssignment to fetch.
     */
    where?: BagAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BagAssignments to fetch.
     */
    orderBy?: BagAssignmentOrderByWithRelationInput | BagAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BagAssignments.
     */
    cursor?: BagAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BagAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BagAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BagAssignments.
     */
    distinct?: BagAssignmentScalarFieldEnum | BagAssignmentScalarFieldEnum[]
  }

  /**
   * BagAssignment findMany
   */
  export type BagAssignmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BagAssignment
     */
    select?: BagAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BagAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which BagAssignments to fetch.
     */
    where?: BagAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BagAssignments to fetch.
     */
    orderBy?: BagAssignmentOrderByWithRelationInput | BagAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BagAssignments.
     */
    cursor?: BagAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BagAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BagAssignments.
     */
    skip?: number
    distinct?: BagAssignmentScalarFieldEnum | BagAssignmentScalarFieldEnum[]
  }

  /**
   * BagAssignment create
   */
  export type BagAssignmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BagAssignment
     */
    select?: BagAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BagAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to create a BagAssignment.
     */
    data: XOR<BagAssignmentCreateInput, BagAssignmentUncheckedCreateInput>
  }

  /**
   * BagAssignment createMany
   */
  export type BagAssignmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BagAssignments.
     */
    data: BagAssignmentCreateManyInput | BagAssignmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BagAssignment createManyAndReturn
   */
  export type BagAssignmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BagAssignment
     */
    select?: BagAssignmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BagAssignments.
     */
    data: BagAssignmentCreateManyInput | BagAssignmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BagAssignmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BagAssignment update
   */
  export type BagAssignmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BagAssignment
     */
    select?: BagAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BagAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to update a BagAssignment.
     */
    data: XOR<BagAssignmentUpdateInput, BagAssignmentUncheckedUpdateInput>
    /**
     * Choose, which BagAssignment to update.
     */
    where: BagAssignmentWhereUniqueInput
  }

  /**
   * BagAssignment updateMany
   */
  export type BagAssignmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BagAssignments.
     */
    data: XOR<BagAssignmentUpdateManyMutationInput, BagAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which BagAssignments to update
     */
    where?: BagAssignmentWhereInput
  }

  /**
   * BagAssignment upsert
   */
  export type BagAssignmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BagAssignment
     */
    select?: BagAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BagAssignmentInclude<ExtArgs> | null
    /**
     * The filter to search for the BagAssignment to update in case it exists.
     */
    where: BagAssignmentWhereUniqueInput
    /**
     * In case the BagAssignment found by the `where` argument doesn't exist, create a new BagAssignment with this data.
     */
    create: XOR<BagAssignmentCreateInput, BagAssignmentUncheckedCreateInput>
    /**
     * In case the BagAssignment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BagAssignmentUpdateInput, BagAssignmentUncheckedUpdateInput>
  }

  /**
   * BagAssignment delete
   */
  export type BagAssignmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BagAssignment
     */
    select?: BagAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BagAssignmentInclude<ExtArgs> | null
    /**
     * Filter which BagAssignment to delete.
     */
    where: BagAssignmentWhereUniqueInput
  }

  /**
   * BagAssignment deleteMany
   */
  export type BagAssignmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BagAssignments to delete
     */
    where?: BagAssignmentWhereInput
  }

  /**
   * BagAssignment without action
   */
  export type BagAssignmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BagAssignment
     */
    select?: BagAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BagAssignmentInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    name: string | null
    role: $Enums.UserRole | null
    terminal: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    name: string | null
    role: $Enums.UserRole | null
    terminal: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    passwordHash: number
    name: number
    role: number
    terminal: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    name?: true
    role?: true
    terminal?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    name?: true
    role?: true
    terminal?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    name?: true
    role?: true
    terminal?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    passwordHash: string
    name: string
    role: $Enums.UserRole
    terminal: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    name?: boolean
    role?: boolean
    terminal?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    name?: boolean
    role?: boolean
    terminal?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    name?: boolean
    role?: boolean
    terminal?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      passwordHash: string
      name: string
      role: $Enums.UserRole
      terminal: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly terminal: FieldRef<"User", 'String'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const IncomingFlightScalarFieldEnum: {
    id: 'id',
    flightNumber: 'flightNumber',
    terminal: 'terminal',
    origin: 'origin',
    scheduledTime: 'scheduledTime',
    actualArrivalTime: 'actualArrivalTime',
    expectedArrivalTime: 'expectedArrivalTime',
    cancelled: 'cancelled',
    collectedTime: 'collectedTime',
    deliveredTime: 'deliveredTime',
    screeningStartTime: 'screeningStartTime',
    screeningEndTime: 'screeningEndTime',
    screeningBags: 'screeningBags',
    bagAvailableTime: 'bagAvailableTime',
    carousel: 'carousel',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type IncomingFlightScalarFieldEnum = (typeof IncomingFlightScalarFieldEnum)[keyof typeof IncomingFlightScalarFieldEnum]


  export const OutgoingFlightScalarFieldEnum: {
    id: 'id',
    flightNumber: 'flightNumber',
    terminal: 'terminal',
    destination: 'destination',
    scheduledTime: 'scheduledTime',
    actualTime: 'actualTime',
    expectedTime: 'expectedTime',
    cancelled: 'cancelled',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OutgoingFlightScalarFieldEnum = (typeof OutgoingFlightScalarFieldEnum)[keyof typeof OutgoingFlightScalarFieldEnum]


  export const OutgoingLinkScalarFieldEnum: {
    id: 'id',
    incomingFlightId: 'incomingFlightId',
    outgoingFlightId: 'outgoingFlightId',
    bagCount: 'bagCount',
    isMAGTransfer: 'isMAGTransfer',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OutgoingLinkScalarFieldEnum = (typeof OutgoingLinkScalarFieldEnum)[keyof typeof OutgoingLinkScalarFieldEnum]


  export const BagAssignmentScalarFieldEnum: {
    id: 'id',
    outgoingFlightId: 'outgoingFlightId',
    incomingFlightNumber: 'incomingFlightNumber',
    bagCount: 'bagCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BagAssignmentScalarFieldEnum = (typeof BagAssignmentScalarFieldEnum)[keyof typeof BagAssignmentScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    passwordHash: 'passwordHash',
    name: 'name',
    role: 'role',
    terminal: 'terminal',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type IncomingFlightWhereInput = {
    AND?: IncomingFlightWhereInput | IncomingFlightWhereInput[]
    OR?: IncomingFlightWhereInput[]
    NOT?: IncomingFlightWhereInput | IncomingFlightWhereInput[]
    id?: StringFilter<"IncomingFlight"> | string
    flightNumber?: StringFilter<"IncomingFlight"> | string
    terminal?: StringFilter<"IncomingFlight"> | string
    origin?: StringFilter<"IncomingFlight"> | string
    scheduledTime?: DateTimeFilter<"IncomingFlight"> | Date | string
    actualArrivalTime?: DateTimeNullableFilter<"IncomingFlight"> | Date | string | null
    expectedArrivalTime?: DateTimeNullableFilter<"IncomingFlight"> | Date | string | null
    cancelled?: BoolFilter<"IncomingFlight"> | boolean
    collectedTime?: DateTimeNullableFilter<"IncomingFlight"> | Date | string | null
    deliveredTime?: DateTimeNullableFilter<"IncomingFlight"> | Date | string | null
    screeningStartTime?: DateTimeNullableFilter<"IncomingFlight"> | Date | string | null
    screeningEndTime?: DateTimeNullableFilter<"IncomingFlight"> | Date | string | null
    screeningBags?: IntNullableFilter<"IncomingFlight"> | number | null
    bagAvailableTime?: DateTimeNullableFilter<"IncomingFlight"> | Date | string | null
    carousel?: StringNullableFilter<"IncomingFlight"> | string | null
    notes?: StringFilter<"IncomingFlight"> | string
    createdAt?: DateTimeFilter<"IncomingFlight"> | Date | string
    updatedAt?: DateTimeFilter<"IncomingFlight"> | Date | string
    outgoingLinks?: OutgoingLinkListRelationFilter
  }

  export type IncomingFlightOrderByWithRelationInput = {
    id?: SortOrder
    flightNumber?: SortOrder
    terminal?: SortOrder
    origin?: SortOrder
    scheduledTime?: SortOrder
    actualArrivalTime?: SortOrderInput | SortOrder
    expectedArrivalTime?: SortOrderInput | SortOrder
    cancelled?: SortOrder
    collectedTime?: SortOrderInput | SortOrder
    deliveredTime?: SortOrderInput | SortOrder
    screeningStartTime?: SortOrderInput | SortOrder
    screeningEndTime?: SortOrderInput | SortOrder
    screeningBags?: SortOrderInput | SortOrder
    bagAvailableTime?: SortOrderInput | SortOrder
    carousel?: SortOrderInput | SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    outgoingLinks?: OutgoingLinkOrderByRelationAggregateInput
  }

  export type IncomingFlightWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: IncomingFlightWhereInput | IncomingFlightWhereInput[]
    OR?: IncomingFlightWhereInput[]
    NOT?: IncomingFlightWhereInput | IncomingFlightWhereInput[]
    flightNumber?: StringFilter<"IncomingFlight"> | string
    terminal?: StringFilter<"IncomingFlight"> | string
    origin?: StringFilter<"IncomingFlight"> | string
    scheduledTime?: DateTimeFilter<"IncomingFlight"> | Date | string
    actualArrivalTime?: DateTimeNullableFilter<"IncomingFlight"> | Date | string | null
    expectedArrivalTime?: DateTimeNullableFilter<"IncomingFlight"> | Date | string | null
    cancelled?: BoolFilter<"IncomingFlight"> | boolean
    collectedTime?: DateTimeNullableFilter<"IncomingFlight"> | Date | string | null
    deliveredTime?: DateTimeNullableFilter<"IncomingFlight"> | Date | string | null
    screeningStartTime?: DateTimeNullableFilter<"IncomingFlight"> | Date | string | null
    screeningEndTime?: DateTimeNullableFilter<"IncomingFlight"> | Date | string | null
    screeningBags?: IntNullableFilter<"IncomingFlight"> | number | null
    bagAvailableTime?: DateTimeNullableFilter<"IncomingFlight"> | Date | string | null
    carousel?: StringNullableFilter<"IncomingFlight"> | string | null
    notes?: StringFilter<"IncomingFlight"> | string
    createdAt?: DateTimeFilter<"IncomingFlight"> | Date | string
    updatedAt?: DateTimeFilter<"IncomingFlight"> | Date | string
    outgoingLinks?: OutgoingLinkListRelationFilter
  }, "id">

  export type IncomingFlightOrderByWithAggregationInput = {
    id?: SortOrder
    flightNumber?: SortOrder
    terminal?: SortOrder
    origin?: SortOrder
    scheduledTime?: SortOrder
    actualArrivalTime?: SortOrderInput | SortOrder
    expectedArrivalTime?: SortOrderInput | SortOrder
    cancelled?: SortOrder
    collectedTime?: SortOrderInput | SortOrder
    deliveredTime?: SortOrderInput | SortOrder
    screeningStartTime?: SortOrderInput | SortOrder
    screeningEndTime?: SortOrderInput | SortOrder
    screeningBags?: SortOrderInput | SortOrder
    bagAvailableTime?: SortOrderInput | SortOrder
    carousel?: SortOrderInput | SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: IncomingFlightCountOrderByAggregateInput
    _avg?: IncomingFlightAvgOrderByAggregateInput
    _max?: IncomingFlightMaxOrderByAggregateInput
    _min?: IncomingFlightMinOrderByAggregateInput
    _sum?: IncomingFlightSumOrderByAggregateInput
  }

  export type IncomingFlightScalarWhereWithAggregatesInput = {
    AND?: IncomingFlightScalarWhereWithAggregatesInput | IncomingFlightScalarWhereWithAggregatesInput[]
    OR?: IncomingFlightScalarWhereWithAggregatesInput[]
    NOT?: IncomingFlightScalarWhereWithAggregatesInput | IncomingFlightScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"IncomingFlight"> | string
    flightNumber?: StringWithAggregatesFilter<"IncomingFlight"> | string
    terminal?: StringWithAggregatesFilter<"IncomingFlight"> | string
    origin?: StringWithAggregatesFilter<"IncomingFlight"> | string
    scheduledTime?: DateTimeWithAggregatesFilter<"IncomingFlight"> | Date | string
    actualArrivalTime?: DateTimeNullableWithAggregatesFilter<"IncomingFlight"> | Date | string | null
    expectedArrivalTime?: DateTimeNullableWithAggregatesFilter<"IncomingFlight"> | Date | string | null
    cancelled?: BoolWithAggregatesFilter<"IncomingFlight"> | boolean
    collectedTime?: DateTimeNullableWithAggregatesFilter<"IncomingFlight"> | Date | string | null
    deliveredTime?: DateTimeNullableWithAggregatesFilter<"IncomingFlight"> | Date | string | null
    screeningStartTime?: DateTimeNullableWithAggregatesFilter<"IncomingFlight"> | Date | string | null
    screeningEndTime?: DateTimeNullableWithAggregatesFilter<"IncomingFlight"> | Date | string | null
    screeningBags?: IntNullableWithAggregatesFilter<"IncomingFlight"> | number | null
    bagAvailableTime?: DateTimeNullableWithAggregatesFilter<"IncomingFlight"> | Date | string | null
    carousel?: StringNullableWithAggregatesFilter<"IncomingFlight"> | string | null
    notes?: StringWithAggregatesFilter<"IncomingFlight"> | string
    createdAt?: DateTimeWithAggregatesFilter<"IncomingFlight"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"IncomingFlight"> | Date | string
  }

  export type OutgoingFlightWhereInput = {
    AND?: OutgoingFlightWhereInput | OutgoingFlightWhereInput[]
    OR?: OutgoingFlightWhereInput[]
    NOT?: OutgoingFlightWhereInput | OutgoingFlightWhereInput[]
    id?: StringFilter<"OutgoingFlight"> | string
    flightNumber?: StringFilter<"OutgoingFlight"> | string
    terminal?: StringFilter<"OutgoingFlight"> | string
    destination?: StringFilter<"OutgoingFlight"> | string
    scheduledTime?: DateTimeFilter<"OutgoingFlight"> | Date | string
    actualTime?: DateTimeNullableFilter<"OutgoingFlight"> | Date | string | null
    expectedTime?: DateTimeNullableFilter<"OutgoingFlight"> | Date | string | null
    cancelled?: BoolFilter<"OutgoingFlight"> | boolean
    createdAt?: DateTimeFilter<"OutgoingFlight"> | Date | string
    updatedAt?: DateTimeFilter<"OutgoingFlight"> | Date | string
    incomingLinks?: OutgoingLinkListRelationFilter
    bagsFromIncoming?: BagAssignmentListRelationFilter
  }

  export type OutgoingFlightOrderByWithRelationInput = {
    id?: SortOrder
    flightNumber?: SortOrder
    terminal?: SortOrder
    destination?: SortOrder
    scheduledTime?: SortOrder
    actualTime?: SortOrderInput | SortOrder
    expectedTime?: SortOrderInput | SortOrder
    cancelled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    incomingLinks?: OutgoingLinkOrderByRelationAggregateInput
    bagsFromIncoming?: BagAssignmentOrderByRelationAggregateInput
  }

  export type OutgoingFlightWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OutgoingFlightWhereInput | OutgoingFlightWhereInput[]
    OR?: OutgoingFlightWhereInput[]
    NOT?: OutgoingFlightWhereInput | OutgoingFlightWhereInput[]
    flightNumber?: StringFilter<"OutgoingFlight"> | string
    terminal?: StringFilter<"OutgoingFlight"> | string
    destination?: StringFilter<"OutgoingFlight"> | string
    scheduledTime?: DateTimeFilter<"OutgoingFlight"> | Date | string
    actualTime?: DateTimeNullableFilter<"OutgoingFlight"> | Date | string | null
    expectedTime?: DateTimeNullableFilter<"OutgoingFlight"> | Date | string | null
    cancelled?: BoolFilter<"OutgoingFlight"> | boolean
    createdAt?: DateTimeFilter<"OutgoingFlight"> | Date | string
    updatedAt?: DateTimeFilter<"OutgoingFlight"> | Date | string
    incomingLinks?: OutgoingLinkListRelationFilter
    bagsFromIncoming?: BagAssignmentListRelationFilter
  }, "id">

  export type OutgoingFlightOrderByWithAggregationInput = {
    id?: SortOrder
    flightNumber?: SortOrder
    terminal?: SortOrder
    destination?: SortOrder
    scheduledTime?: SortOrder
    actualTime?: SortOrderInput | SortOrder
    expectedTime?: SortOrderInput | SortOrder
    cancelled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OutgoingFlightCountOrderByAggregateInput
    _max?: OutgoingFlightMaxOrderByAggregateInput
    _min?: OutgoingFlightMinOrderByAggregateInput
  }

  export type OutgoingFlightScalarWhereWithAggregatesInput = {
    AND?: OutgoingFlightScalarWhereWithAggregatesInput | OutgoingFlightScalarWhereWithAggregatesInput[]
    OR?: OutgoingFlightScalarWhereWithAggregatesInput[]
    NOT?: OutgoingFlightScalarWhereWithAggregatesInput | OutgoingFlightScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OutgoingFlight"> | string
    flightNumber?: StringWithAggregatesFilter<"OutgoingFlight"> | string
    terminal?: StringWithAggregatesFilter<"OutgoingFlight"> | string
    destination?: StringWithAggregatesFilter<"OutgoingFlight"> | string
    scheduledTime?: DateTimeWithAggregatesFilter<"OutgoingFlight"> | Date | string
    actualTime?: DateTimeNullableWithAggregatesFilter<"OutgoingFlight"> | Date | string | null
    expectedTime?: DateTimeNullableWithAggregatesFilter<"OutgoingFlight"> | Date | string | null
    cancelled?: BoolWithAggregatesFilter<"OutgoingFlight"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"OutgoingFlight"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OutgoingFlight"> | Date | string
  }

  export type OutgoingLinkWhereInput = {
    AND?: OutgoingLinkWhereInput | OutgoingLinkWhereInput[]
    OR?: OutgoingLinkWhereInput[]
    NOT?: OutgoingLinkWhereInput | OutgoingLinkWhereInput[]
    id?: StringFilter<"OutgoingLink"> | string
    incomingFlightId?: StringFilter<"OutgoingLink"> | string
    outgoingFlightId?: StringFilter<"OutgoingLink"> | string
    bagCount?: IntFilter<"OutgoingLink"> | number
    isMAGTransfer?: BoolFilter<"OutgoingLink"> | boolean
    createdAt?: DateTimeFilter<"OutgoingLink"> | Date | string
    updatedAt?: DateTimeFilter<"OutgoingLink"> | Date | string
    incomingFlight?: XOR<IncomingFlightRelationFilter, IncomingFlightWhereInput>
    outgoingFlight?: XOR<OutgoingFlightRelationFilter, OutgoingFlightWhereInput>
  }

  export type OutgoingLinkOrderByWithRelationInput = {
    id?: SortOrder
    incomingFlightId?: SortOrder
    outgoingFlightId?: SortOrder
    bagCount?: SortOrder
    isMAGTransfer?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    incomingFlight?: IncomingFlightOrderByWithRelationInput
    outgoingFlight?: OutgoingFlightOrderByWithRelationInput
  }

  export type OutgoingLinkWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    incomingFlightId_outgoingFlightId?: OutgoingLinkIncomingFlightIdOutgoingFlightIdCompoundUniqueInput
    AND?: OutgoingLinkWhereInput | OutgoingLinkWhereInput[]
    OR?: OutgoingLinkWhereInput[]
    NOT?: OutgoingLinkWhereInput | OutgoingLinkWhereInput[]
    incomingFlightId?: StringFilter<"OutgoingLink"> | string
    outgoingFlightId?: StringFilter<"OutgoingLink"> | string
    bagCount?: IntFilter<"OutgoingLink"> | number
    isMAGTransfer?: BoolFilter<"OutgoingLink"> | boolean
    createdAt?: DateTimeFilter<"OutgoingLink"> | Date | string
    updatedAt?: DateTimeFilter<"OutgoingLink"> | Date | string
    incomingFlight?: XOR<IncomingFlightRelationFilter, IncomingFlightWhereInput>
    outgoingFlight?: XOR<OutgoingFlightRelationFilter, OutgoingFlightWhereInput>
  }, "id" | "incomingFlightId_outgoingFlightId">

  export type OutgoingLinkOrderByWithAggregationInput = {
    id?: SortOrder
    incomingFlightId?: SortOrder
    outgoingFlightId?: SortOrder
    bagCount?: SortOrder
    isMAGTransfer?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OutgoingLinkCountOrderByAggregateInput
    _avg?: OutgoingLinkAvgOrderByAggregateInput
    _max?: OutgoingLinkMaxOrderByAggregateInput
    _min?: OutgoingLinkMinOrderByAggregateInput
    _sum?: OutgoingLinkSumOrderByAggregateInput
  }

  export type OutgoingLinkScalarWhereWithAggregatesInput = {
    AND?: OutgoingLinkScalarWhereWithAggregatesInput | OutgoingLinkScalarWhereWithAggregatesInput[]
    OR?: OutgoingLinkScalarWhereWithAggregatesInput[]
    NOT?: OutgoingLinkScalarWhereWithAggregatesInput | OutgoingLinkScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OutgoingLink"> | string
    incomingFlightId?: StringWithAggregatesFilter<"OutgoingLink"> | string
    outgoingFlightId?: StringWithAggregatesFilter<"OutgoingLink"> | string
    bagCount?: IntWithAggregatesFilter<"OutgoingLink"> | number
    isMAGTransfer?: BoolWithAggregatesFilter<"OutgoingLink"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"OutgoingLink"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OutgoingLink"> | Date | string
  }

  export type BagAssignmentWhereInput = {
    AND?: BagAssignmentWhereInput | BagAssignmentWhereInput[]
    OR?: BagAssignmentWhereInput[]
    NOT?: BagAssignmentWhereInput | BagAssignmentWhereInput[]
    id?: StringFilter<"BagAssignment"> | string
    outgoingFlightId?: StringFilter<"BagAssignment"> | string
    incomingFlightNumber?: StringFilter<"BagAssignment"> | string
    bagCount?: IntFilter<"BagAssignment"> | number
    createdAt?: DateTimeFilter<"BagAssignment"> | Date | string
    updatedAt?: DateTimeFilter<"BagAssignment"> | Date | string
    outgoingFlight?: XOR<OutgoingFlightRelationFilter, OutgoingFlightWhereInput>
  }

  export type BagAssignmentOrderByWithRelationInput = {
    id?: SortOrder
    outgoingFlightId?: SortOrder
    incomingFlightNumber?: SortOrder
    bagCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    outgoingFlight?: OutgoingFlightOrderByWithRelationInput
  }

  export type BagAssignmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    outgoingFlightId_incomingFlightNumber?: BagAssignmentOutgoingFlightIdIncomingFlightNumberCompoundUniqueInput
    AND?: BagAssignmentWhereInput | BagAssignmentWhereInput[]
    OR?: BagAssignmentWhereInput[]
    NOT?: BagAssignmentWhereInput | BagAssignmentWhereInput[]
    outgoingFlightId?: StringFilter<"BagAssignment"> | string
    incomingFlightNumber?: StringFilter<"BagAssignment"> | string
    bagCount?: IntFilter<"BagAssignment"> | number
    createdAt?: DateTimeFilter<"BagAssignment"> | Date | string
    updatedAt?: DateTimeFilter<"BagAssignment"> | Date | string
    outgoingFlight?: XOR<OutgoingFlightRelationFilter, OutgoingFlightWhereInput>
  }, "id" | "outgoingFlightId_incomingFlightNumber">

  export type BagAssignmentOrderByWithAggregationInput = {
    id?: SortOrder
    outgoingFlightId?: SortOrder
    incomingFlightNumber?: SortOrder
    bagCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BagAssignmentCountOrderByAggregateInput
    _avg?: BagAssignmentAvgOrderByAggregateInput
    _max?: BagAssignmentMaxOrderByAggregateInput
    _min?: BagAssignmentMinOrderByAggregateInput
    _sum?: BagAssignmentSumOrderByAggregateInput
  }

  export type BagAssignmentScalarWhereWithAggregatesInput = {
    AND?: BagAssignmentScalarWhereWithAggregatesInput | BagAssignmentScalarWhereWithAggregatesInput[]
    OR?: BagAssignmentScalarWhereWithAggregatesInput[]
    NOT?: BagAssignmentScalarWhereWithAggregatesInput | BagAssignmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BagAssignment"> | string
    outgoingFlightId?: StringWithAggregatesFilter<"BagAssignment"> | string
    incomingFlightNumber?: StringWithAggregatesFilter<"BagAssignment"> | string
    bagCount?: IntWithAggregatesFilter<"BagAssignment"> | number
    createdAt?: DateTimeWithAggregatesFilter<"BagAssignment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BagAssignment"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    terminal?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    name?: SortOrder
    role?: SortOrder
    terminal?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    passwordHash?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    terminal?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    name?: SortOrder
    role?: SortOrder
    terminal?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    terminal?: StringNullableWithAggregatesFilter<"User"> | string | null
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type IncomingFlightCreateInput = {
    id?: string
    flightNumber: string
    terminal: string
    origin: string
    scheduledTime: Date | string
    actualArrivalTime?: Date | string | null
    expectedArrivalTime?: Date | string | null
    cancelled?: boolean
    collectedTime?: Date | string | null
    deliveredTime?: Date | string | null
    screeningStartTime?: Date | string | null
    screeningEndTime?: Date | string | null
    screeningBags?: number | null
    bagAvailableTime?: Date | string | null
    carousel?: string | null
    notes?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    outgoingLinks?: OutgoingLinkCreateNestedManyWithoutIncomingFlightInput
  }

  export type IncomingFlightUncheckedCreateInput = {
    id?: string
    flightNumber: string
    terminal: string
    origin: string
    scheduledTime: Date | string
    actualArrivalTime?: Date | string | null
    expectedArrivalTime?: Date | string | null
    cancelled?: boolean
    collectedTime?: Date | string | null
    deliveredTime?: Date | string | null
    screeningStartTime?: Date | string | null
    screeningEndTime?: Date | string | null
    screeningBags?: number | null
    bagAvailableTime?: Date | string | null
    carousel?: string | null
    notes?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    outgoingLinks?: OutgoingLinkUncheckedCreateNestedManyWithoutIncomingFlightInput
  }

  export type IncomingFlightUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    flightNumber?: StringFieldUpdateOperationsInput | string
    terminal?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    scheduledTime?: DateTimeFieldUpdateOperationsInput | Date | string
    actualArrivalTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedArrivalTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelled?: BoolFieldUpdateOperationsInput | boolean
    collectedTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    screeningStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    screeningEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    screeningBags?: NullableIntFieldUpdateOperationsInput | number | null
    bagAvailableTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    carousel?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    outgoingLinks?: OutgoingLinkUpdateManyWithoutIncomingFlightNestedInput
  }

  export type IncomingFlightUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    flightNumber?: StringFieldUpdateOperationsInput | string
    terminal?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    scheduledTime?: DateTimeFieldUpdateOperationsInput | Date | string
    actualArrivalTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedArrivalTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelled?: BoolFieldUpdateOperationsInput | boolean
    collectedTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    screeningStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    screeningEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    screeningBags?: NullableIntFieldUpdateOperationsInput | number | null
    bagAvailableTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    carousel?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    outgoingLinks?: OutgoingLinkUncheckedUpdateManyWithoutIncomingFlightNestedInput
  }

  export type IncomingFlightCreateManyInput = {
    id?: string
    flightNumber: string
    terminal: string
    origin: string
    scheduledTime: Date | string
    actualArrivalTime?: Date | string | null
    expectedArrivalTime?: Date | string | null
    cancelled?: boolean
    collectedTime?: Date | string | null
    deliveredTime?: Date | string | null
    screeningStartTime?: Date | string | null
    screeningEndTime?: Date | string | null
    screeningBags?: number | null
    bagAvailableTime?: Date | string | null
    carousel?: string | null
    notes?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IncomingFlightUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    flightNumber?: StringFieldUpdateOperationsInput | string
    terminal?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    scheduledTime?: DateTimeFieldUpdateOperationsInput | Date | string
    actualArrivalTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedArrivalTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelled?: BoolFieldUpdateOperationsInput | boolean
    collectedTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    screeningStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    screeningEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    screeningBags?: NullableIntFieldUpdateOperationsInput | number | null
    bagAvailableTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    carousel?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncomingFlightUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    flightNumber?: StringFieldUpdateOperationsInput | string
    terminal?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    scheduledTime?: DateTimeFieldUpdateOperationsInput | Date | string
    actualArrivalTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedArrivalTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelled?: BoolFieldUpdateOperationsInput | boolean
    collectedTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    screeningStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    screeningEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    screeningBags?: NullableIntFieldUpdateOperationsInput | number | null
    bagAvailableTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    carousel?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OutgoingFlightCreateInput = {
    id?: string
    flightNumber: string
    terminal: string
    destination: string
    scheduledTime: Date | string
    actualTime?: Date | string | null
    expectedTime?: Date | string | null
    cancelled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    incomingLinks?: OutgoingLinkCreateNestedManyWithoutOutgoingFlightInput
    bagsFromIncoming?: BagAssignmentCreateNestedManyWithoutOutgoingFlightInput
  }

  export type OutgoingFlightUncheckedCreateInput = {
    id?: string
    flightNumber: string
    terminal: string
    destination: string
    scheduledTime: Date | string
    actualTime?: Date | string | null
    expectedTime?: Date | string | null
    cancelled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    incomingLinks?: OutgoingLinkUncheckedCreateNestedManyWithoutOutgoingFlightInput
    bagsFromIncoming?: BagAssignmentUncheckedCreateNestedManyWithoutOutgoingFlightInput
  }

  export type OutgoingFlightUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    flightNumber?: StringFieldUpdateOperationsInput | string
    terminal?: StringFieldUpdateOperationsInput | string
    destination?: StringFieldUpdateOperationsInput | string
    scheduledTime?: DateTimeFieldUpdateOperationsInput | Date | string
    actualTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    incomingLinks?: OutgoingLinkUpdateManyWithoutOutgoingFlightNestedInput
    bagsFromIncoming?: BagAssignmentUpdateManyWithoutOutgoingFlightNestedInput
  }

  export type OutgoingFlightUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    flightNumber?: StringFieldUpdateOperationsInput | string
    terminal?: StringFieldUpdateOperationsInput | string
    destination?: StringFieldUpdateOperationsInput | string
    scheduledTime?: DateTimeFieldUpdateOperationsInput | Date | string
    actualTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    incomingLinks?: OutgoingLinkUncheckedUpdateManyWithoutOutgoingFlightNestedInput
    bagsFromIncoming?: BagAssignmentUncheckedUpdateManyWithoutOutgoingFlightNestedInput
  }

  export type OutgoingFlightCreateManyInput = {
    id?: string
    flightNumber: string
    terminal: string
    destination: string
    scheduledTime: Date | string
    actualTime?: Date | string | null
    expectedTime?: Date | string | null
    cancelled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OutgoingFlightUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    flightNumber?: StringFieldUpdateOperationsInput | string
    terminal?: StringFieldUpdateOperationsInput | string
    destination?: StringFieldUpdateOperationsInput | string
    scheduledTime?: DateTimeFieldUpdateOperationsInput | Date | string
    actualTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OutgoingFlightUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    flightNumber?: StringFieldUpdateOperationsInput | string
    terminal?: StringFieldUpdateOperationsInput | string
    destination?: StringFieldUpdateOperationsInput | string
    scheduledTime?: DateTimeFieldUpdateOperationsInput | Date | string
    actualTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OutgoingLinkCreateInput = {
    id?: string
    bagCount?: number
    isMAGTransfer?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    incomingFlight: IncomingFlightCreateNestedOneWithoutOutgoingLinksInput
    outgoingFlight: OutgoingFlightCreateNestedOneWithoutIncomingLinksInput
  }

  export type OutgoingLinkUncheckedCreateInput = {
    id?: string
    incomingFlightId: string
    outgoingFlightId: string
    bagCount?: number
    isMAGTransfer?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OutgoingLinkUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bagCount?: IntFieldUpdateOperationsInput | number
    isMAGTransfer?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    incomingFlight?: IncomingFlightUpdateOneRequiredWithoutOutgoingLinksNestedInput
    outgoingFlight?: OutgoingFlightUpdateOneRequiredWithoutIncomingLinksNestedInput
  }

  export type OutgoingLinkUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    incomingFlightId?: StringFieldUpdateOperationsInput | string
    outgoingFlightId?: StringFieldUpdateOperationsInput | string
    bagCount?: IntFieldUpdateOperationsInput | number
    isMAGTransfer?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OutgoingLinkCreateManyInput = {
    id?: string
    incomingFlightId: string
    outgoingFlightId: string
    bagCount?: number
    isMAGTransfer?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OutgoingLinkUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    bagCount?: IntFieldUpdateOperationsInput | number
    isMAGTransfer?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OutgoingLinkUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    incomingFlightId?: StringFieldUpdateOperationsInput | string
    outgoingFlightId?: StringFieldUpdateOperationsInput | string
    bagCount?: IntFieldUpdateOperationsInput | number
    isMAGTransfer?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BagAssignmentCreateInput = {
    id?: string
    incomingFlightNumber: string
    bagCount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    outgoingFlight: OutgoingFlightCreateNestedOneWithoutBagsFromIncomingInput
  }

  export type BagAssignmentUncheckedCreateInput = {
    id?: string
    outgoingFlightId: string
    incomingFlightNumber: string
    bagCount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BagAssignmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    incomingFlightNumber?: StringFieldUpdateOperationsInput | string
    bagCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    outgoingFlight?: OutgoingFlightUpdateOneRequiredWithoutBagsFromIncomingNestedInput
  }

  export type BagAssignmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    outgoingFlightId?: StringFieldUpdateOperationsInput | string
    incomingFlightNumber?: StringFieldUpdateOperationsInput | string
    bagCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BagAssignmentCreateManyInput = {
    id?: string
    outgoingFlightId: string
    incomingFlightNumber: string
    bagCount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BagAssignmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    incomingFlightNumber?: StringFieldUpdateOperationsInput | string
    bagCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BagAssignmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    outgoingFlightId?: StringFieldUpdateOperationsInput | string
    incomingFlightNumber?: StringFieldUpdateOperationsInput | string
    bagCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    passwordHash: string
    name: string
    role?: $Enums.UserRole
    terminal?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    passwordHash: string
    name: string
    role?: $Enums.UserRole
    terminal?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    terminal?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    terminal?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    passwordHash: string
    name: string
    role?: $Enums.UserRole
    terminal?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    terminal?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    terminal?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type OutgoingLinkListRelationFilter = {
    every?: OutgoingLinkWhereInput
    some?: OutgoingLinkWhereInput
    none?: OutgoingLinkWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type OutgoingLinkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IncomingFlightCountOrderByAggregateInput = {
    id?: SortOrder
    flightNumber?: SortOrder
    terminal?: SortOrder
    origin?: SortOrder
    scheduledTime?: SortOrder
    actualArrivalTime?: SortOrder
    expectedArrivalTime?: SortOrder
    cancelled?: SortOrder
    collectedTime?: SortOrder
    deliveredTime?: SortOrder
    screeningStartTime?: SortOrder
    screeningEndTime?: SortOrder
    screeningBags?: SortOrder
    bagAvailableTime?: SortOrder
    carousel?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IncomingFlightAvgOrderByAggregateInput = {
    screeningBags?: SortOrder
  }

  export type IncomingFlightMaxOrderByAggregateInput = {
    id?: SortOrder
    flightNumber?: SortOrder
    terminal?: SortOrder
    origin?: SortOrder
    scheduledTime?: SortOrder
    actualArrivalTime?: SortOrder
    expectedArrivalTime?: SortOrder
    cancelled?: SortOrder
    collectedTime?: SortOrder
    deliveredTime?: SortOrder
    screeningStartTime?: SortOrder
    screeningEndTime?: SortOrder
    screeningBags?: SortOrder
    bagAvailableTime?: SortOrder
    carousel?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IncomingFlightMinOrderByAggregateInput = {
    id?: SortOrder
    flightNumber?: SortOrder
    terminal?: SortOrder
    origin?: SortOrder
    scheduledTime?: SortOrder
    actualArrivalTime?: SortOrder
    expectedArrivalTime?: SortOrder
    cancelled?: SortOrder
    collectedTime?: SortOrder
    deliveredTime?: SortOrder
    screeningStartTime?: SortOrder
    screeningEndTime?: SortOrder
    screeningBags?: SortOrder
    bagAvailableTime?: SortOrder
    carousel?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IncomingFlightSumOrderByAggregateInput = {
    screeningBags?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BagAssignmentListRelationFilter = {
    every?: BagAssignmentWhereInput
    some?: BagAssignmentWhereInput
    none?: BagAssignmentWhereInput
  }

  export type BagAssignmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OutgoingFlightCountOrderByAggregateInput = {
    id?: SortOrder
    flightNumber?: SortOrder
    terminal?: SortOrder
    destination?: SortOrder
    scheduledTime?: SortOrder
    actualTime?: SortOrder
    expectedTime?: SortOrder
    cancelled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OutgoingFlightMaxOrderByAggregateInput = {
    id?: SortOrder
    flightNumber?: SortOrder
    terminal?: SortOrder
    destination?: SortOrder
    scheduledTime?: SortOrder
    actualTime?: SortOrder
    expectedTime?: SortOrder
    cancelled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OutgoingFlightMinOrderByAggregateInput = {
    id?: SortOrder
    flightNumber?: SortOrder
    terminal?: SortOrder
    destination?: SortOrder
    scheduledTime?: SortOrder
    actualTime?: SortOrder
    expectedTime?: SortOrder
    cancelled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type IncomingFlightRelationFilter = {
    is?: IncomingFlightWhereInput
    isNot?: IncomingFlightWhereInput
  }

  export type OutgoingFlightRelationFilter = {
    is?: OutgoingFlightWhereInput
    isNot?: OutgoingFlightWhereInput
  }

  export type OutgoingLinkIncomingFlightIdOutgoingFlightIdCompoundUniqueInput = {
    incomingFlightId: string
    outgoingFlightId: string
  }

  export type OutgoingLinkCountOrderByAggregateInput = {
    id?: SortOrder
    incomingFlightId?: SortOrder
    outgoingFlightId?: SortOrder
    bagCount?: SortOrder
    isMAGTransfer?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OutgoingLinkAvgOrderByAggregateInput = {
    bagCount?: SortOrder
  }

  export type OutgoingLinkMaxOrderByAggregateInput = {
    id?: SortOrder
    incomingFlightId?: SortOrder
    outgoingFlightId?: SortOrder
    bagCount?: SortOrder
    isMAGTransfer?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OutgoingLinkMinOrderByAggregateInput = {
    id?: SortOrder
    incomingFlightId?: SortOrder
    outgoingFlightId?: SortOrder
    bagCount?: SortOrder
    isMAGTransfer?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OutgoingLinkSumOrderByAggregateInput = {
    bagCount?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type BagAssignmentOutgoingFlightIdIncomingFlightNumberCompoundUniqueInput = {
    outgoingFlightId: string
    incomingFlightNumber: string
  }

  export type BagAssignmentCountOrderByAggregateInput = {
    id?: SortOrder
    outgoingFlightId?: SortOrder
    incomingFlightNumber?: SortOrder
    bagCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BagAssignmentAvgOrderByAggregateInput = {
    bagCount?: SortOrder
  }

  export type BagAssignmentMaxOrderByAggregateInput = {
    id?: SortOrder
    outgoingFlightId?: SortOrder
    incomingFlightNumber?: SortOrder
    bagCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BagAssignmentMinOrderByAggregateInput = {
    id?: SortOrder
    outgoingFlightId?: SortOrder
    incomingFlightNumber?: SortOrder
    bagCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BagAssignmentSumOrderByAggregateInput = {
    bagCount?: SortOrder
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    name?: SortOrder
    role?: SortOrder
    terminal?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    name?: SortOrder
    role?: SortOrder
    terminal?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    name?: SortOrder
    role?: SortOrder
    terminal?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type OutgoingLinkCreateNestedManyWithoutIncomingFlightInput = {
    create?: XOR<OutgoingLinkCreateWithoutIncomingFlightInput, OutgoingLinkUncheckedCreateWithoutIncomingFlightInput> | OutgoingLinkCreateWithoutIncomingFlightInput[] | OutgoingLinkUncheckedCreateWithoutIncomingFlightInput[]
    connectOrCreate?: OutgoingLinkCreateOrConnectWithoutIncomingFlightInput | OutgoingLinkCreateOrConnectWithoutIncomingFlightInput[]
    createMany?: OutgoingLinkCreateManyIncomingFlightInputEnvelope
    connect?: OutgoingLinkWhereUniqueInput | OutgoingLinkWhereUniqueInput[]
  }

  export type OutgoingLinkUncheckedCreateNestedManyWithoutIncomingFlightInput = {
    create?: XOR<OutgoingLinkCreateWithoutIncomingFlightInput, OutgoingLinkUncheckedCreateWithoutIncomingFlightInput> | OutgoingLinkCreateWithoutIncomingFlightInput[] | OutgoingLinkUncheckedCreateWithoutIncomingFlightInput[]
    connectOrCreate?: OutgoingLinkCreateOrConnectWithoutIncomingFlightInput | OutgoingLinkCreateOrConnectWithoutIncomingFlightInput[]
    createMany?: OutgoingLinkCreateManyIncomingFlightInputEnvelope
    connect?: OutgoingLinkWhereUniqueInput | OutgoingLinkWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type OutgoingLinkUpdateManyWithoutIncomingFlightNestedInput = {
    create?: XOR<OutgoingLinkCreateWithoutIncomingFlightInput, OutgoingLinkUncheckedCreateWithoutIncomingFlightInput> | OutgoingLinkCreateWithoutIncomingFlightInput[] | OutgoingLinkUncheckedCreateWithoutIncomingFlightInput[]
    connectOrCreate?: OutgoingLinkCreateOrConnectWithoutIncomingFlightInput | OutgoingLinkCreateOrConnectWithoutIncomingFlightInput[]
    upsert?: OutgoingLinkUpsertWithWhereUniqueWithoutIncomingFlightInput | OutgoingLinkUpsertWithWhereUniqueWithoutIncomingFlightInput[]
    createMany?: OutgoingLinkCreateManyIncomingFlightInputEnvelope
    set?: OutgoingLinkWhereUniqueInput | OutgoingLinkWhereUniqueInput[]
    disconnect?: OutgoingLinkWhereUniqueInput | OutgoingLinkWhereUniqueInput[]
    delete?: OutgoingLinkWhereUniqueInput | OutgoingLinkWhereUniqueInput[]
    connect?: OutgoingLinkWhereUniqueInput | OutgoingLinkWhereUniqueInput[]
    update?: OutgoingLinkUpdateWithWhereUniqueWithoutIncomingFlightInput | OutgoingLinkUpdateWithWhereUniqueWithoutIncomingFlightInput[]
    updateMany?: OutgoingLinkUpdateManyWithWhereWithoutIncomingFlightInput | OutgoingLinkUpdateManyWithWhereWithoutIncomingFlightInput[]
    deleteMany?: OutgoingLinkScalarWhereInput | OutgoingLinkScalarWhereInput[]
  }

  export type OutgoingLinkUncheckedUpdateManyWithoutIncomingFlightNestedInput = {
    create?: XOR<OutgoingLinkCreateWithoutIncomingFlightInput, OutgoingLinkUncheckedCreateWithoutIncomingFlightInput> | OutgoingLinkCreateWithoutIncomingFlightInput[] | OutgoingLinkUncheckedCreateWithoutIncomingFlightInput[]
    connectOrCreate?: OutgoingLinkCreateOrConnectWithoutIncomingFlightInput | OutgoingLinkCreateOrConnectWithoutIncomingFlightInput[]
    upsert?: OutgoingLinkUpsertWithWhereUniqueWithoutIncomingFlightInput | OutgoingLinkUpsertWithWhereUniqueWithoutIncomingFlightInput[]
    createMany?: OutgoingLinkCreateManyIncomingFlightInputEnvelope
    set?: OutgoingLinkWhereUniqueInput | OutgoingLinkWhereUniqueInput[]
    disconnect?: OutgoingLinkWhereUniqueInput | OutgoingLinkWhereUniqueInput[]
    delete?: OutgoingLinkWhereUniqueInput | OutgoingLinkWhereUniqueInput[]
    connect?: OutgoingLinkWhereUniqueInput | OutgoingLinkWhereUniqueInput[]
    update?: OutgoingLinkUpdateWithWhereUniqueWithoutIncomingFlightInput | OutgoingLinkUpdateWithWhereUniqueWithoutIncomingFlightInput[]
    updateMany?: OutgoingLinkUpdateManyWithWhereWithoutIncomingFlightInput | OutgoingLinkUpdateManyWithWhereWithoutIncomingFlightInput[]
    deleteMany?: OutgoingLinkScalarWhereInput | OutgoingLinkScalarWhereInput[]
  }

  export type OutgoingLinkCreateNestedManyWithoutOutgoingFlightInput = {
    create?: XOR<OutgoingLinkCreateWithoutOutgoingFlightInput, OutgoingLinkUncheckedCreateWithoutOutgoingFlightInput> | OutgoingLinkCreateWithoutOutgoingFlightInput[] | OutgoingLinkUncheckedCreateWithoutOutgoingFlightInput[]
    connectOrCreate?: OutgoingLinkCreateOrConnectWithoutOutgoingFlightInput | OutgoingLinkCreateOrConnectWithoutOutgoingFlightInput[]
    createMany?: OutgoingLinkCreateManyOutgoingFlightInputEnvelope
    connect?: OutgoingLinkWhereUniqueInput | OutgoingLinkWhereUniqueInput[]
  }

  export type BagAssignmentCreateNestedManyWithoutOutgoingFlightInput = {
    create?: XOR<BagAssignmentCreateWithoutOutgoingFlightInput, BagAssignmentUncheckedCreateWithoutOutgoingFlightInput> | BagAssignmentCreateWithoutOutgoingFlightInput[] | BagAssignmentUncheckedCreateWithoutOutgoingFlightInput[]
    connectOrCreate?: BagAssignmentCreateOrConnectWithoutOutgoingFlightInput | BagAssignmentCreateOrConnectWithoutOutgoingFlightInput[]
    createMany?: BagAssignmentCreateManyOutgoingFlightInputEnvelope
    connect?: BagAssignmentWhereUniqueInput | BagAssignmentWhereUniqueInput[]
  }

  export type OutgoingLinkUncheckedCreateNestedManyWithoutOutgoingFlightInput = {
    create?: XOR<OutgoingLinkCreateWithoutOutgoingFlightInput, OutgoingLinkUncheckedCreateWithoutOutgoingFlightInput> | OutgoingLinkCreateWithoutOutgoingFlightInput[] | OutgoingLinkUncheckedCreateWithoutOutgoingFlightInput[]
    connectOrCreate?: OutgoingLinkCreateOrConnectWithoutOutgoingFlightInput | OutgoingLinkCreateOrConnectWithoutOutgoingFlightInput[]
    createMany?: OutgoingLinkCreateManyOutgoingFlightInputEnvelope
    connect?: OutgoingLinkWhereUniqueInput | OutgoingLinkWhereUniqueInput[]
  }

  export type BagAssignmentUncheckedCreateNestedManyWithoutOutgoingFlightInput = {
    create?: XOR<BagAssignmentCreateWithoutOutgoingFlightInput, BagAssignmentUncheckedCreateWithoutOutgoingFlightInput> | BagAssignmentCreateWithoutOutgoingFlightInput[] | BagAssignmentUncheckedCreateWithoutOutgoingFlightInput[]
    connectOrCreate?: BagAssignmentCreateOrConnectWithoutOutgoingFlightInput | BagAssignmentCreateOrConnectWithoutOutgoingFlightInput[]
    createMany?: BagAssignmentCreateManyOutgoingFlightInputEnvelope
    connect?: BagAssignmentWhereUniqueInput | BagAssignmentWhereUniqueInput[]
  }

  export type OutgoingLinkUpdateManyWithoutOutgoingFlightNestedInput = {
    create?: XOR<OutgoingLinkCreateWithoutOutgoingFlightInput, OutgoingLinkUncheckedCreateWithoutOutgoingFlightInput> | OutgoingLinkCreateWithoutOutgoingFlightInput[] | OutgoingLinkUncheckedCreateWithoutOutgoingFlightInput[]
    connectOrCreate?: OutgoingLinkCreateOrConnectWithoutOutgoingFlightInput | OutgoingLinkCreateOrConnectWithoutOutgoingFlightInput[]
    upsert?: OutgoingLinkUpsertWithWhereUniqueWithoutOutgoingFlightInput | OutgoingLinkUpsertWithWhereUniqueWithoutOutgoingFlightInput[]
    createMany?: OutgoingLinkCreateManyOutgoingFlightInputEnvelope
    set?: OutgoingLinkWhereUniqueInput | OutgoingLinkWhereUniqueInput[]
    disconnect?: OutgoingLinkWhereUniqueInput | OutgoingLinkWhereUniqueInput[]
    delete?: OutgoingLinkWhereUniqueInput | OutgoingLinkWhereUniqueInput[]
    connect?: OutgoingLinkWhereUniqueInput | OutgoingLinkWhereUniqueInput[]
    update?: OutgoingLinkUpdateWithWhereUniqueWithoutOutgoingFlightInput | OutgoingLinkUpdateWithWhereUniqueWithoutOutgoingFlightInput[]
    updateMany?: OutgoingLinkUpdateManyWithWhereWithoutOutgoingFlightInput | OutgoingLinkUpdateManyWithWhereWithoutOutgoingFlightInput[]
    deleteMany?: OutgoingLinkScalarWhereInput | OutgoingLinkScalarWhereInput[]
  }

  export type BagAssignmentUpdateManyWithoutOutgoingFlightNestedInput = {
    create?: XOR<BagAssignmentCreateWithoutOutgoingFlightInput, BagAssignmentUncheckedCreateWithoutOutgoingFlightInput> | BagAssignmentCreateWithoutOutgoingFlightInput[] | BagAssignmentUncheckedCreateWithoutOutgoingFlightInput[]
    connectOrCreate?: BagAssignmentCreateOrConnectWithoutOutgoingFlightInput | BagAssignmentCreateOrConnectWithoutOutgoingFlightInput[]
    upsert?: BagAssignmentUpsertWithWhereUniqueWithoutOutgoingFlightInput | BagAssignmentUpsertWithWhereUniqueWithoutOutgoingFlightInput[]
    createMany?: BagAssignmentCreateManyOutgoingFlightInputEnvelope
    set?: BagAssignmentWhereUniqueInput | BagAssignmentWhereUniqueInput[]
    disconnect?: BagAssignmentWhereUniqueInput | BagAssignmentWhereUniqueInput[]
    delete?: BagAssignmentWhereUniqueInput | BagAssignmentWhereUniqueInput[]
    connect?: BagAssignmentWhereUniqueInput | BagAssignmentWhereUniqueInput[]
    update?: BagAssignmentUpdateWithWhereUniqueWithoutOutgoingFlightInput | BagAssignmentUpdateWithWhereUniqueWithoutOutgoingFlightInput[]
    updateMany?: BagAssignmentUpdateManyWithWhereWithoutOutgoingFlightInput | BagAssignmentUpdateManyWithWhereWithoutOutgoingFlightInput[]
    deleteMany?: BagAssignmentScalarWhereInput | BagAssignmentScalarWhereInput[]
  }

  export type OutgoingLinkUncheckedUpdateManyWithoutOutgoingFlightNestedInput = {
    create?: XOR<OutgoingLinkCreateWithoutOutgoingFlightInput, OutgoingLinkUncheckedCreateWithoutOutgoingFlightInput> | OutgoingLinkCreateWithoutOutgoingFlightInput[] | OutgoingLinkUncheckedCreateWithoutOutgoingFlightInput[]
    connectOrCreate?: OutgoingLinkCreateOrConnectWithoutOutgoingFlightInput | OutgoingLinkCreateOrConnectWithoutOutgoingFlightInput[]
    upsert?: OutgoingLinkUpsertWithWhereUniqueWithoutOutgoingFlightInput | OutgoingLinkUpsertWithWhereUniqueWithoutOutgoingFlightInput[]
    createMany?: OutgoingLinkCreateManyOutgoingFlightInputEnvelope
    set?: OutgoingLinkWhereUniqueInput | OutgoingLinkWhereUniqueInput[]
    disconnect?: OutgoingLinkWhereUniqueInput | OutgoingLinkWhereUniqueInput[]
    delete?: OutgoingLinkWhereUniqueInput | OutgoingLinkWhereUniqueInput[]
    connect?: OutgoingLinkWhereUniqueInput | OutgoingLinkWhereUniqueInput[]
    update?: OutgoingLinkUpdateWithWhereUniqueWithoutOutgoingFlightInput | OutgoingLinkUpdateWithWhereUniqueWithoutOutgoingFlightInput[]
    updateMany?: OutgoingLinkUpdateManyWithWhereWithoutOutgoingFlightInput | OutgoingLinkUpdateManyWithWhereWithoutOutgoingFlightInput[]
    deleteMany?: OutgoingLinkScalarWhereInput | OutgoingLinkScalarWhereInput[]
  }

  export type BagAssignmentUncheckedUpdateManyWithoutOutgoingFlightNestedInput = {
    create?: XOR<BagAssignmentCreateWithoutOutgoingFlightInput, BagAssignmentUncheckedCreateWithoutOutgoingFlightInput> | BagAssignmentCreateWithoutOutgoingFlightInput[] | BagAssignmentUncheckedCreateWithoutOutgoingFlightInput[]
    connectOrCreate?: BagAssignmentCreateOrConnectWithoutOutgoingFlightInput | BagAssignmentCreateOrConnectWithoutOutgoingFlightInput[]
    upsert?: BagAssignmentUpsertWithWhereUniqueWithoutOutgoingFlightInput | BagAssignmentUpsertWithWhereUniqueWithoutOutgoingFlightInput[]
    createMany?: BagAssignmentCreateManyOutgoingFlightInputEnvelope
    set?: BagAssignmentWhereUniqueInput | BagAssignmentWhereUniqueInput[]
    disconnect?: BagAssignmentWhereUniqueInput | BagAssignmentWhereUniqueInput[]
    delete?: BagAssignmentWhereUniqueInput | BagAssignmentWhereUniqueInput[]
    connect?: BagAssignmentWhereUniqueInput | BagAssignmentWhereUniqueInput[]
    update?: BagAssignmentUpdateWithWhereUniqueWithoutOutgoingFlightInput | BagAssignmentUpdateWithWhereUniqueWithoutOutgoingFlightInput[]
    updateMany?: BagAssignmentUpdateManyWithWhereWithoutOutgoingFlightInput | BagAssignmentUpdateManyWithWhereWithoutOutgoingFlightInput[]
    deleteMany?: BagAssignmentScalarWhereInput | BagAssignmentScalarWhereInput[]
  }

  export type IncomingFlightCreateNestedOneWithoutOutgoingLinksInput = {
    create?: XOR<IncomingFlightCreateWithoutOutgoingLinksInput, IncomingFlightUncheckedCreateWithoutOutgoingLinksInput>
    connectOrCreate?: IncomingFlightCreateOrConnectWithoutOutgoingLinksInput
    connect?: IncomingFlightWhereUniqueInput
  }

  export type OutgoingFlightCreateNestedOneWithoutIncomingLinksInput = {
    create?: XOR<OutgoingFlightCreateWithoutIncomingLinksInput, OutgoingFlightUncheckedCreateWithoutIncomingLinksInput>
    connectOrCreate?: OutgoingFlightCreateOrConnectWithoutIncomingLinksInput
    connect?: OutgoingFlightWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type IncomingFlightUpdateOneRequiredWithoutOutgoingLinksNestedInput = {
    create?: XOR<IncomingFlightCreateWithoutOutgoingLinksInput, IncomingFlightUncheckedCreateWithoutOutgoingLinksInput>
    connectOrCreate?: IncomingFlightCreateOrConnectWithoutOutgoingLinksInput
    upsert?: IncomingFlightUpsertWithoutOutgoingLinksInput
    connect?: IncomingFlightWhereUniqueInput
    update?: XOR<XOR<IncomingFlightUpdateToOneWithWhereWithoutOutgoingLinksInput, IncomingFlightUpdateWithoutOutgoingLinksInput>, IncomingFlightUncheckedUpdateWithoutOutgoingLinksInput>
  }

  export type OutgoingFlightUpdateOneRequiredWithoutIncomingLinksNestedInput = {
    create?: XOR<OutgoingFlightCreateWithoutIncomingLinksInput, OutgoingFlightUncheckedCreateWithoutIncomingLinksInput>
    connectOrCreate?: OutgoingFlightCreateOrConnectWithoutIncomingLinksInput
    upsert?: OutgoingFlightUpsertWithoutIncomingLinksInput
    connect?: OutgoingFlightWhereUniqueInput
    update?: XOR<XOR<OutgoingFlightUpdateToOneWithWhereWithoutIncomingLinksInput, OutgoingFlightUpdateWithoutIncomingLinksInput>, OutgoingFlightUncheckedUpdateWithoutIncomingLinksInput>
  }

  export type OutgoingFlightCreateNestedOneWithoutBagsFromIncomingInput = {
    create?: XOR<OutgoingFlightCreateWithoutBagsFromIncomingInput, OutgoingFlightUncheckedCreateWithoutBagsFromIncomingInput>
    connectOrCreate?: OutgoingFlightCreateOrConnectWithoutBagsFromIncomingInput
    connect?: OutgoingFlightWhereUniqueInput
  }

  export type OutgoingFlightUpdateOneRequiredWithoutBagsFromIncomingNestedInput = {
    create?: XOR<OutgoingFlightCreateWithoutBagsFromIncomingInput, OutgoingFlightUncheckedCreateWithoutBagsFromIncomingInput>
    connectOrCreate?: OutgoingFlightCreateOrConnectWithoutBagsFromIncomingInput
    upsert?: OutgoingFlightUpsertWithoutBagsFromIncomingInput
    connect?: OutgoingFlightWhereUniqueInput
    update?: XOR<XOR<OutgoingFlightUpdateToOneWithWhereWithoutBagsFromIncomingInput, OutgoingFlightUpdateWithoutBagsFromIncomingInput>, OutgoingFlightUncheckedUpdateWithoutBagsFromIncomingInput>
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type OutgoingLinkCreateWithoutIncomingFlightInput = {
    id?: string
    bagCount?: number
    isMAGTransfer?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    outgoingFlight: OutgoingFlightCreateNestedOneWithoutIncomingLinksInput
  }

  export type OutgoingLinkUncheckedCreateWithoutIncomingFlightInput = {
    id?: string
    outgoingFlightId: string
    bagCount?: number
    isMAGTransfer?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OutgoingLinkCreateOrConnectWithoutIncomingFlightInput = {
    where: OutgoingLinkWhereUniqueInput
    create: XOR<OutgoingLinkCreateWithoutIncomingFlightInput, OutgoingLinkUncheckedCreateWithoutIncomingFlightInput>
  }

  export type OutgoingLinkCreateManyIncomingFlightInputEnvelope = {
    data: OutgoingLinkCreateManyIncomingFlightInput | OutgoingLinkCreateManyIncomingFlightInput[]
    skipDuplicates?: boolean
  }

  export type OutgoingLinkUpsertWithWhereUniqueWithoutIncomingFlightInput = {
    where: OutgoingLinkWhereUniqueInput
    update: XOR<OutgoingLinkUpdateWithoutIncomingFlightInput, OutgoingLinkUncheckedUpdateWithoutIncomingFlightInput>
    create: XOR<OutgoingLinkCreateWithoutIncomingFlightInput, OutgoingLinkUncheckedCreateWithoutIncomingFlightInput>
  }

  export type OutgoingLinkUpdateWithWhereUniqueWithoutIncomingFlightInput = {
    where: OutgoingLinkWhereUniqueInput
    data: XOR<OutgoingLinkUpdateWithoutIncomingFlightInput, OutgoingLinkUncheckedUpdateWithoutIncomingFlightInput>
  }

  export type OutgoingLinkUpdateManyWithWhereWithoutIncomingFlightInput = {
    where: OutgoingLinkScalarWhereInput
    data: XOR<OutgoingLinkUpdateManyMutationInput, OutgoingLinkUncheckedUpdateManyWithoutIncomingFlightInput>
  }

  export type OutgoingLinkScalarWhereInput = {
    AND?: OutgoingLinkScalarWhereInput | OutgoingLinkScalarWhereInput[]
    OR?: OutgoingLinkScalarWhereInput[]
    NOT?: OutgoingLinkScalarWhereInput | OutgoingLinkScalarWhereInput[]
    id?: StringFilter<"OutgoingLink"> | string
    incomingFlightId?: StringFilter<"OutgoingLink"> | string
    outgoingFlightId?: StringFilter<"OutgoingLink"> | string
    bagCount?: IntFilter<"OutgoingLink"> | number
    isMAGTransfer?: BoolFilter<"OutgoingLink"> | boolean
    createdAt?: DateTimeFilter<"OutgoingLink"> | Date | string
    updatedAt?: DateTimeFilter<"OutgoingLink"> | Date | string
  }

  export type OutgoingLinkCreateWithoutOutgoingFlightInput = {
    id?: string
    bagCount?: number
    isMAGTransfer?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    incomingFlight: IncomingFlightCreateNestedOneWithoutOutgoingLinksInput
  }

  export type OutgoingLinkUncheckedCreateWithoutOutgoingFlightInput = {
    id?: string
    incomingFlightId: string
    bagCount?: number
    isMAGTransfer?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OutgoingLinkCreateOrConnectWithoutOutgoingFlightInput = {
    where: OutgoingLinkWhereUniqueInput
    create: XOR<OutgoingLinkCreateWithoutOutgoingFlightInput, OutgoingLinkUncheckedCreateWithoutOutgoingFlightInput>
  }

  export type OutgoingLinkCreateManyOutgoingFlightInputEnvelope = {
    data: OutgoingLinkCreateManyOutgoingFlightInput | OutgoingLinkCreateManyOutgoingFlightInput[]
    skipDuplicates?: boolean
  }

  export type BagAssignmentCreateWithoutOutgoingFlightInput = {
    id?: string
    incomingFlightNumber: string
    bagCount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BagAssignmentUncheckedCreateWithoutOutgoingFlightInput = {
    id?: string
    incomingFlightNumber: string
    bagCount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BagAssignmentCreateOrConnectWithoutOutgoingFlightInput = {
    where: BagAssignmentWhereUniqueInput
    create: XOR<BagAssignmentCreateWithoutOutgoingFlightInput, BagAssignmentUncheckedCreateWithoutOutgoingFlightInput>
  }

  export type BagAssignmentCreateManyOutgoingFlightInputEnvelope = {
    data: BagAssignmentCreateManyOutgoingFlightInput | BagAssignmentCreateManyOutgoingFlightInput[]
    skipDuplicates?: boolean
  }

  export type OutgoingLinkUpsertWithWhereUniqueWithoutOutgoingFlightInput = {
    where: OutgoingLinkWhereUniqueInput
    update: XOR<OutgoingLinkUpdateWithoutOutgoingFlightInput, OutgoingLinkUncheckedUpdateWithoutOutgoingFlightInput>
    create: XOR<OutgoingLinkCreateWithoutOutgoingFlightInput, OutgoingLinkUncheckedCreateWithoutOutgoingFlightInput>
  }

  export type OutgoingLinkUpdateWithWhereUniqueWithoutOutgoingFlightInput = {
    where: OutgoingLinkWhereUniqueInput
    data: XOR<OutgoingLinkUpdateWithoutOutgoingFlightInput, OutgoingLinkUncheckedUpdateWithoutOutgoingFlightInput>
  }

  export type OutgoingLinkUpdateManyWithWhereWithoutOutgoingFlightInput = {
    where: OutgoingLinkScalarWhereInput
    data: XOR<OutgoingLinkUpdateManyMutationInput, OutgoingLinkUncheckedUpdateManyWithoutOutgoingFlightInput>
  }

  export type BagAssignmentUpsertWithWhereUniqueWithoutOutgoingFlightInput = {
    where: BagAssignmentWhereUniqueInput
    update: XOR<BagAssignmentUpdateWithoutOutgoingFlightInput, BagAssignmentUncheckedUpdateWithoutOutgoingFlightInput>
    create: XOR<BagAssignmentCreateWithoutOutgoingFlightInput, BagAssignmentUncheckedCreateWithoutOutgoingFlightInput>
  }

  export type BagAssignmentUpdateWithWhereUniqueWithoutOutgoingFlightInput = {
    where: BagAssignmentWhereUniqueInput
    data: XOR<BagAssignmentUpdateWithoutOutgoingFlightInput, BagAssignmentUncheckedUpdateWithoutOutgoingFlightInput>
  }

  export type BagAssignmentUpdateManyWithWhereWithoutOutgoingFlightInput = {
    where: BagAssignmentScalarWhereInput
    data: XOR<BagAssignmentUpdateManyMutationInput, BagAssignmentUncheckedUpdateManyWithoutOutgoingFlightInput>
  }

  export type BagAssignmentScalarWhereInput = {
    AND?: BagAssignmentScalarWhereInput | BagAssignmentScalarWhereInput[]
    OR?: BagAssignmentScalarWhereInput[]
    NOT?: BagAssignmentScalarWhereInput | BagAssignmentScalarWhereInput[]
    id?: StringFilter<"BagAssignment"> | string
    outgoingFlightId?: StringFilter<"BagAssignment"> | string
    incomingFlightNumber?: StringFilter<"BagAssignment"> | string
    bagCount?: IntFilter<"BagAssignment"> | number
    createdAt?: DateTimeFilter<"BagAssignment"> | Date | string
    updatedAt?: DateTimeFilter<"BagAssignment"> | Date | string
  }

  export type IncomingFlightCreateWithoutOutgoingLinksInput = {
    id?: string
    flightNumber: string
    terminal: string
    origin: string
    scheduledTime: Date | string
    actualArrivalTime?: Date | string | null
    expectedArrivalTime?: Date | string | null
    cancelled?: boolean
    collectedTime?: Date | string | null
    deliveredTime?: Date | string | null
    screeningStartTime?: Date | string | null
    screeningEndTime?: Date | string | null
    screeningBags?: number | null
    bagAvailableTime?: Date | string | null
    carousel?: string | null
    notes?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IncomingFlightUncheckedCreateWithoutOutgoingLinksInput = {
    id?: string
    flightNumber: string
    terminal: string
    origin: string
    scheduledTime: Date | string
    actualArrivalTime?: Date | string | null
    expectedArrivalTime?: Date | string | null
    cancelled?: boolean
    collectedTime?: Date | string | null
    deliveredTime?: Date | string | null
    screeningStartTime?: Date | string | null
    screeningEndTime?: Date | string | null
    screeningBags?: number | null
    bagAvailableTime?: Date | string | null
    carousel?: string | null
    notes?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IncomingFlightCreateOrConnectWithoutOutgoingLinksInput = {
    where: IncomingFlightWhereUniqueInput
    create: XOR<IncomingFlightCreateWithoutOutgoingLinksInput, IncomingFlightUncheckedCreateWithoutOutgoingLinksInput>
  }

  export type OutgoingFlightCreateWithoutIncomingLinksInput = {
    id?: string
    flightNumber: string
    terminal: string
    destination: string
    scheduledTime: Date | string
    actualTime?: Date | string | null
    expectedTime?: Date | string | null
    cancelled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bagsFromIncoming?: BagAssignmentCreateNestedManyWithoutOutgoingFlightInput
  }

  export type OutgoingFlightUncheckedCreateWithoutIncomingLinksInput = {
    id?: string
    flightNumber: string
    terminal: string
    destination: string
    scheduledTime: Date | string
    actualTime?: Date | string | null
    expectedTime?: Date | string | null
    cancelled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bagsFromIncoming?: BagAssignmentUncheckedCreateNestedManyWithoutOutgoingFlightInput
  }

  export type OutgoingFlightCreateOrConnectWithoutIncomingLinksInput = {
    where: OutgoingFlightWhereUniqueInput
    create: XOR<OutgoingFlightCreateWithoutIncomingLinksInput, OutgoingFlightUncheckedCreateWithoutIncomingLinksInput>
  }

  export type IncomingFlightUpsertWithoutOutgoingLinksInput = {
    update: XOR<IncomingFlightUpdateWithoutOutgoingLinksInput, IncomingFlightUncheckedUpdateWithoutOutgoingLinksInput>
    create: XOR<IncomingFlightCreateWithoutOutgoingLinksInput, IncomingFlightUncheckedCreateWithoutOutgoingLinksInput>
    where?: IncomingFlightWhereInput
  }

  export type IncomingFlightUpdateToOneWithWhereWithoutOutgoingLinksInput = {
    where?: IncomingFlightWhereInput
    data: XOR<IncomingFlightUpdateWithoutOutgoingLinksInput, IncomingFlightUncheckedUpdateWithoutOutgoingLinksInput>
  }

  export type IncomingFlightUpdateWithoutOutgoingLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    flightNumber?: StringFieldUpdateOperationsInput | string
    terminal?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    scheduledTime?: DateTimeFieldUpdateOperationsInput | Date | string
    actualArrivalTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedArrivalTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelled?: BoolFieldUpdateOperationsInput | boolean
    collectedTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    screeningStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    screeningEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    screeningBags?: NullableIntFieldUpdateOperationsInput | number | null
    bagAvailableTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    carousel?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncomingFlightUncheckedUpdateWithoutOutgoingLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    flightNumber?: StringFieldUpdateOperationsInput | string
    terminal?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    scheduledTime?: DateTimeFieldUpdateOperationsInput | Date | string
    actualArrivalTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedArrivalTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelled?: BoolFieldUpdateOperationsInput | boolean
    collectedTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    screeningStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    screeningEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    screeningBags?: NullableIntFieldUpdateOperationsInput | number | null
    bagAvailableTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    carousel?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OutgoingFlightUpsertWithoutIncomingLinksInput = {
    update: XOR<OutgoingFlightUpdateWithoutIncomingLinksInput, OutgoingFlightUncheckedUpdateWithoutIncomingLinksInput>
    create: XOR<OutgoingFlightCreateWithoutIncomingLinksInput, OutgoingFlightUncheckedCreateWithoutIncomingLinksInput>
    where?: OutgoingFlightWhereInput
  }

  export type OutgoingFlightUpdateToOneWithWhereWithoutIncomingLinksInput = {
    where?: OutgoingFlightWhereInput
    data: XOR<OutgoingFlightUpdateWithoutIncomingLinksInput, OutgoingFlightUncheckedUpdateWithoutIncomingLinksInput>
  }

  export type OutgoingFlightUpdateWithoutIncomingLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    flightNumber?: StringFieldUpdateOperationsInput | string
    terminal?: StringFieldUpdateOperationsInput | string
    destination?: StringFieldUpdateOperationsInput | string
    scheduledTime?: DateTimeFieldUpdateOperationsInput | Date | string
    actualTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bagsFromIncoming?: BagAssignmentUpdateManyWithoutOutgoingFlightNestedInput
  }

  export type OutgoingFlightUncheckedUpdateWithoutIncomingLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    flightNumber?: StringFieldUpdateOperationsInput | string
    terminal?: StringFieldUpdateOperationsInput | string
    destination?: StringFieldUpdateOperationsInput | string
    scheduledTime?: DateTimeFieldUpdateOperationsInput | Date | string
    actualTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bagsFromIncoming?: BagAssignmentUncheckedUpdateManyWithoutOutgoingFlightNestedInput
  }

  export type OutgoingFlightCreateWithoutBagsFromIncomingInput = {
    id?: string
    flightNumber: string
    terminal: string
    destination: string
    scheduledTime: Date | string
    actualTime?: Date | string | null
    expectedTime?: Date | string | null
    cancelled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    incomingLinks?: OutgoingLinkCreateNestedManyWithoutOutgoingFlightInput
  }

  export type OutgoingFlightUncheckedCreateWithoutBagsFromIncomingInput = {
    id?: string
    flightNumber: string
    terminal: string
    destination: string
    scheduledTime: Date | string
    actualTime?: Date | string | null
    expectedTime?: Date | string | null
    cancelled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    incomingLinks?: OutgoingLinkUncheckedCreateNestedManyWithoutOutgoingFlightInput
  }

  export type OutgoingFlightCreateOrConnectWithoutBagsFromIncomingInput = {
    where: OutgoingFlightWhereUniqueInput
    create: XOR<OutgoingFlightCreateWithoutBagsFromIncomingInput, OutgoingFlightUncheckedCreateWithoutBagsFromIncomingInput>
  }

  export type OutgoingFlightUpsertWithoutBagsFromIncomingInput = {
    update: XOR<OutgoingFlightUpdateWithoutBagsFromIncomingInput, OutgoingFlightUncheckedUpdateWithoutBagsFromIncomingInput>
    create: XOR<OutgoingFlightCreateWithoutBagsFromIncomingInput, OutgoingFlightUncheckedCreateWithoutBagsFromIncomingInput>
    where?: OutgoingFlightWhereInput
  }

  export type OutgoingFlightUpdateToOneWithWhereWithoutBagsFromIncomingInput = {
    where?: OutgoingFlightWhereInput
    data: XOR<OutgoingFlightUpdateWithoutBagsFromIncomingInput, OutgoingFlightUncheckedUpdateWithoutBagsFromIncomingInput>
  }

  export type OutgoingFlightUpdateWithoutBagsFromIncomingInput = {
    id?: StringFieldUpdateOperationsInput | string
    flightNumber?: StringFieldUpdateOperationsInput | string
    terminal?: StringFieldUpdateOperationsInput | string
    destination?: StringFieldUpdateOperationsInput | string
    scheduledTime?: DateTimeFieldUpdateOperationsInput | Date | string
    actualTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    incomingLinks?: OutgoingLinkUpdateManyWithoutOutgoingFlightNestedInput
  }

  export type OutgoingFlightUncheckedUpdateWithoutBagsFromIncomingInput = {
    id?: StringFieldUpdateOperationsInput | string
    flightNumber?: StringFieldUpdateOperationsInput | string
    terminal?: StringFieldUpdateOperationsInput | string
    destination?: StringFieldUpdateOperationsInput | string
    scheduledTime?: DateTimeFieldUpdateOperationsInput | Date | string
    actualTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    incomingLinks?: OutgoingLinkUncheckedUpdateManyWithoutOutgoingFlightNestedInput
  }

  export type OutgoingLinkCreateManyIncomingFlightInput = {
    id?: string
    outgoingFlightId: string
    bagCount?: number
    isMAGTransfer?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OutgoingLinkUpdateWithoutIncomingFlightInput = {
    id?: StringFieldUpdateOperationsInput | string
    bagCount?: IntFieldUpdateOperationsInput | number
    isMAGTransfer?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    outgoingFlight?: OutgoingFlightUpdateOneRequiredWithoutIncomingLinksNestedInput
  }

  export type OutgoingLinkUncheckedUpdateWithoutIncomingFlightInput = {
    id?: StringFieldUpdateOperationsInput | string
    outgoingFlightId?: StringFieldUpdateOperationsInput | string
    bagCount?: IntFieldUpdateOperationsInput | number
    isMAGTransfer?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OutgoingLinkUncheckedUpdateManyWithoutIncomingFlightInput = {
    id?: StringFieldUpdateOperationsInput | string
    outgoingFlightId?: StringFieldUpdateOperationsInput | string
    bagCount?: IntFieldUpdateOperationsInput | number
    isMAGTransfer?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OutgoingLinkCreateManyOutgoingFlightInput = {
    id?: string
    incomingFlightId: string
    bagCount?: number
    isMAGTransfer?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BagAssignmentCreateManyOutgoingFlightInput = {
    id?: string
    incomingFlightNumber: string
    bagCount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OutgoingLinkUpdateWithoutOutgoingFlightInput = {
    id?: StringFieldUpdateOperationsInput | string
    bagCount?: IntFieldUpdateOperationsInput | number
    isMAGTransfer?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    incomingFlight?: IncomingFlightUpdateOneRequiredWithoutOutgoingLinksNestedInput
  }

  export type OutgoingLinkUncheckedUpdateWithoutOutgoingFlightInput = {
    id?: StringFieldUpdateOperationsInput | string
    incomingFlightId?: StringFieldUpdateOperationsInput | string
    bagCount?: IntFieldUpdateOperationsInput | number
    isMAGTransfer?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OutgoingLinkUncheckedUpdateManyWithoutOutgoingFlightInput = {
    id?: StringFieldUpdateOperationsInput | string
    incomingFlightId?: StringFieldUpdateOperationsInput | string
    bagCount?: IntFieldUpdateOperationsInput | number
    isMAGTransfer?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BagAssignmentUpdateWithoutOutgoingFlightInput = {
    id?: StringFieldUpdateOperationsInput | string
    incomingFlightNumber?: StringFieldUpdateOperationsInput | string
    bagCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BagAssignmentUncheckedUpdateWithoutOutgoingFlightInput = {
    id?: StringFieldUpdateOperationsInput | string
    incomingFlightNumber?: StringFieldUpdateOperationsInput | string
    bagCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BagAssignmentUncheckedUpdateManyWithoutOutgoingFlightInput = {
    id?: StringFieldUpdateOperationsInput | string
    incomingFlightNumber?: StringFieldUpdateOperationsInput | string
    bagCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use IncomingFlightCountOutputTypeDefaultArgs instead
     */
    export type IncomingFlightCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IncomingFlightCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OutgoingFlightCountOutputTypeDefaultArgs instead
     */
    export type OutgoingFlightCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OutgoingFlightCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use IncomingFlightDefaultArgs instead
     */
    export type IncomingFlightArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IncomingFlightDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OutgoingFlightDefaultArgs instead
     */
    export type OutgoingFlightArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OutgoingFlightDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OutgoingLinkDefaultArgs instead
     */
    export type OutgoingLinkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OutgoingLinkDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BagAssignmentDefaultArgs instead
     */
    export type BagAssignmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BagAssignmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}